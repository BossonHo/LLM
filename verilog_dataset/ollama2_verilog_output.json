[
    {
        "input_prompt": "Implement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of a multiplied by b will be accumulated in this register, and the c shows the value of the register.",
        "ollama_output_code": "module MAC_PE (\n    input               clk     ,  \n    input               rst_n   ,  \n    input       [31:0]  a       ,  \n    input       [31:0]  b       ,  \n    output  reg [63:0]  c        \n);\n\n    reg [63:0] acc;  \n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            acc <= 64'd0;\n        end else begin\n            acc <= acc + a * b;\n        end\n    end\n\n    always @(*) begin\n        c = acc;\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement the design of unsigned 8bit multiplier based on pipelining processing.",
        "ollama_output_code": "module unsigned_multiplier_8bit (\n    input clk,\n    input rst,\n    input [7:0] A,\n    input [7:0] B,\n    output reg [15:0] P\n);\n\n    // Stage 1: Register Inputs\n    reg [7:0] A_reg1, B_reg1;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            A_reg1 <= 8'd0;\n            B_reg1 <= 8'd0;\n        end else begin\n            A_reg1 <= A;\n            B_reg1 <= B;\n        end\n    end\n\n    // Stage 2: Generate Partial Products\n    reg [15:0] partial_products [7:0];\n    integer i;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            for (i = 0; i < 8; i = i + 1)\n                partial_products[i] <= 16'd0;\n        end else begin\n            for (i = 0; i < 8; i = i + 1)\n                partial_products[i] <= (B_reg1[i]) ? ({8'd0, A_reg1} << i) : 16'd0;\n        end\n    end\n\n    // Stage 3: Sum Partials using Tree Adder (Two Levels)\n    reg [15:0] sum1, sum2, sum3, sum4;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum1 <= 16'd0;\n            sum2 <= 16'd0;\n            sum3 <= 16'd0;\n            sum4 <= 16'd0;\n        end else begin\n            sum1 <= partial_products[0] + partial_products[1];\n            sum2 <= partial_products[2] + partial_products[3];\n            sum3 <= partial_products[4] + partial_products[5];\n            sum4 <= partial_products[6] + partial_products[7];\n        end\n    end\n\n    // Stage 4: Final Addition\n    reg [15:0] final_sum;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            final_sum <= 16'd0;\n            P <= 16'd0;\n        end else begin\n            final_sum <= (sum1 + sum2) + (sum3 + sum4);\n            P <= final_sum;\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement the design of unsigned 16bit multiplier based on shifting and adding opration..",
        "ollama_output_code": "module multiplier_16bit (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] A,\n    input [15:0] B,\n    output reg [31:0] P,\n    output reg done\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            P <= 32'd0;\n            done <= 1'b0;\n        end else begin\n            if (start && !done) begin\n                // Initialization on start\n                P <= A * B;\n                done <= 1'b1;\n            end else if (!done) begin\n                P <= P + A * B;\n                done <= 1'b0;\n            end\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a 16-bit divider module, dividend is 16-bit and divider is 8-bit. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.",
        "ollama_output_code": "module divider_16by8 (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] dividend,\n    input [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [7:0] remainder,\n    output reg done\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            quotient <= 16'd0;\n            remainder <= 8'd0;\n        end else begin\n            if (start && !done) begin\n                if (divisor != 0) begin\n                    quotient <= dividend[15:0];\n                    remainder <= dividend[7:0] - divisor[7:0];\n                    done <= 0;\n                end else begin\n                    quotient <= 16'd0;\n                    remainder <= 8'd0;\n                    done <= 1;\n                end\n            end else if (done) begin\n                // no op\n            end else begin\n                // assert fail\n            end\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a module to achieve serial input data accumulation output, input input 8bit data, whenever the module receives 4 input data, the output outputs 4 received data accumulation results. The input and output interfaces interact with the upstream and downstream using the valid-ready two-way handshake mechanism. When both upstream and downstream are required to be able to transmit at full speed, there is no bubble in data transmission, and no additional performance loss can be caused due to the design of this module.",
        "ollama_output_code": "module accumulator_4x8bit (\n    input clk,\n    input rst,\n\n    // Input interface\n    input [7:0] data_in,\n    input       valid_in,\n    output reg  ready_out,\n\n    // Output interface\n    output reg [9:0] data_out,  // Max sum = 4 x 255 = 1020\n    output reg       valid_out,\n    input            ready_in\n);\n\n    reg [9:0] sum;      // Accumulator (up to 1020)\n    reg [1:0] count;    // Count of inputs received (0 to 3)\n\n    always @(*) begin\n        // Accept input when output is not blocking\n        ready_out = (!valid_out) || (valid_out && ready_in);\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum       <= 10'd0;\n            count     <= 2'd0;\n            data_out  <= 10'd0;\n            valid_out <= 1'b0;\n        end else begin\n            // Clear valid_out when downstream has accepted output\n            if (valid_out && ready_in) begin\n                valid_out <= 1'b0;\n            end\n\n            // Accept new input\n            if (valid_in && ready_out) begin\n                sum <= sum + {2'b00, data_in};  // Zero-extend data_in to 10 bits\n                count <= count + 1;\n\n                if (count == 2'd3) begin\n                    data_out <= sum + {2'b00, data_in};  // Final sum\n                    valid_out <= 1'b1;\n                    sum <= 10'd0;\n                    count <= 2'd0;\n                end\n            end\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a module of an 8 bit adder in gate level.",
        "ollama_output_code": "module adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum\n);\n    assign sum = a + b + cin;\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a 16-bit full adder.",
        "ollama_output_code": "module full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a carry lookahead 32 bit adder based on CLAs.",
        "ollama_output_code": "module carry_lookahead_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    // Implement the carry lookahead adder using gates and flip-flops\n    always @(posedge cin or negedge a or negedge b) begin\n        if (cin && (!a || !b)) begin\n            sum <= a + b;\n            cout <= 1'b0; // carry output\n        end else if (cin && (a || b)) begin\n            sum <= a + b + 1'b1; // carry forward\n            cout <= 1'b1; // carry input\n        end else begin\n            sum <= 0; // zero output\n            cout <= 1'b0; // carry input\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16,parameter WIDTH = 8). ",
        "ollama_output_code": "module async_fifo #(\n    parameter DEPTH = 16,\n    parameter WIDTH = 8\n)(\n    input                   rst,\n\n    // Write interface\n    input                   clk_wr,\n    input       [WIDTH-1:0] data_in,\n    input                   wr_en,\n    output                  full,\n\n    // Read interface\n    input                   clk_rd,\n    output      [WIDTH-1:0] data_out,\n    input                   rd_en,\n    output                  empty\n);\n\n    localparam ADDR_WIDTH = $clog2(DEPTH);\n\n    // FIFO memory\n    reg [WIDTH-1:0] mem [0:DEPTH-1];\n\n    // Write pointer (binary and gray)\n    reg [ADDR_WIDTH:0] wr_ptr_bin = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray_sync1 = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray_sync2 = 0;\n\n    // Read pointer (binary and gray)\n    reg [ADDR_WIDTH:0] rd_ptr_bin = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray_sync1 = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray_sync2 = 0;\n\n    wire [ADDR_WIDTH:0] wr_addr = wr_ptr_bin; // Corrected: use the entire wr_ptr_bin\n    wire [ADDR_WIDTH:0] rd_addr = rd_ptr_bin; // Corrected: use the entire rd_ptr_bin\n\n    // === WRITE DOMAIN ===\n    always @(posedge clk_wr or posedge rst) begin\n        if (rst) begin\n            wr_ptr_bin  <= 0;\n            wr_ptr_gray <= 0;\n        end else if (wr_en && !full) begin\n            mem[wr_ptr_bin[ADDR_WIDTH-1:0]] <= data_in;\n            wr_ptr_bin  <= wr_ptr_bin + 1;\n            wr_ptr_gray <= (wr_ptr_bin + 1) ^ ((wr_ptr_bin + 1) >> 1);  // Binary to Gray\n        end\n    end\n\n    // Synchronize read pointer to write domain\n    always @(posedge clk_wr or posedge rst) begin\n        if (rst) begin\n            rd_ptr_gray_sync1 <= 0;\n            rd_ptr_gray_sync2 <= 0;\n        end else begin\n            rd_ptr_gray_sync1 <= rd_ptr_gray;\n            rd_ptr_gray_sync2 <= rd_ptr_gray_sync1;\n        end\n    end\n\n    // FULL condition\n    assign full = (wr_ptr_gray == {~rd_ptr_gray_sync2[ADDR_WIDTH:ADDR_WIDTH-1], rd_ptr_gray_sync2[ADDR_WIDTH-2:0]});\n\n    // === READ DOMAIN ===\n    always @(posedge clk_rd or posedge rst) begin\n        if (rst) begin\n            rd_ptr_bin  <= 0;\n            rd_ptr_gray <= 0;\n        end else if (rd_en && !empty) begin\n            rd_ptr_bin  <= rd_ptr_bin + 1;\n            rd_ptr_gray <= (rd_ptr_bin + 1) ^ ((rd_ptr_bin + 1) >> 1);  // Binary to Gray\n        end\n    end\n\n    assign data_out = mem[rd_ptr_bin[ADDR_WIDTH-1:0]];\n\n    // Synchronize write pointer to read domain\n    always @(posedge clk_rd or posedge rst) begin\n        if (rst) begin\n            wr_ptr_gray_sync1 <= 0;\n            wr_ptr_gray_sync2 <= 0;\n        end else begin\n            wr_ptr_gray_sync1 <= wr_ptr_gray;\n            wr_ptr_gray_sync2 <= wr_ptr_gray_sync1;\n        end\n    end\n\n    // EMPTY condition\n    assign empty = (rd_ptr_gray == wr_ptr_gray_sync2);\n\nendmodule"
    },
    {
        "input_prompt": "Implement a module of perpetual calendar. The output port Secs counts from 0 to 59, and when the Secs count reaches 59, the output port Mins increases by one and stops counting until minute=59. When the Mins count reaches 59, the output port Hours increases by one and stops counting until Hours=24.",
        "ollama_output_code": "module perpetual_calendar (\n    input clk,          // Clock input (assumed 1 Hz for 1-second tick)\n    input rst,          // Asynchronous reset\n    output reg [5:0] Secs,  // 0 - 59\n    output reg [5:0] Mins,  // 0 - 59\n    output reg [4:0] Hours  // 0 - 23\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        Secs  <= 0;\n        Mins  <= 0;\n        Hours <= 0;\n    end else begin\n        if (Secs == 59) begin\n            Secs <= 0;\n\n            if (Mins == 59) begin\n                Mins <= 0;\n\n                if (Hours == 23)\n                    Hours <= 0;\n                else\n                    Hours <= Hours + 1;\n            end else begin\n                Mins <= Mins + 1;\n            end\n        end else begin\n            Secs <= Secs + 1;\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a counter design that requires counting from 4 'b0000 to 4' d12. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is invalid.",
        "ollama_output_code": "module controlled_counter (\n    input        clk,           // Clock input\n    input        rst,           // Active-high synchronous reset\n    input        valid_count,   // Control signal for counting\n    output reg [3:0] count      // 4-bit counter output\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'd0;\n    end else if (valid_count) begin\n        if (count == 4'd12)\n            count <= 4'd0;\n        else\n            count <= count + 1;\n    end\n    // else: hold current count\nendmodule"
    },
    {
        "input_prompt": "Implement a module for edge detection, there is a slowly changing 1 bit signal a. When the rising edge of signal a is detected, the indicating signal rise is given; when the falling edge of signal A is shown, the indicating signal down is given. rise and down are high on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.",
        "ollama_output_code": "module edge_detector (\n    input  wire clk,       // Clock input\n    input  wire rst,       // Active-high reset\n    input  wire a,         // 1-bit slowly changing input signal\n    output reg  rise,      // High for 1 clk on rising edge of a\n    output reg  down       // High for 1 clk on falling edge of a\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        a_d <= 0;\n        rise <= 0;\n        down <= 0;\n    end else begin\n        // Edge detection\n        rise <= (~a_d) & a;   // rising edge\n        down <= a_d & (~a);  // falling edge\n\n        a_d <= a;            // store previous value of a\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.",
        "ollama_output_code": "module frequency_divider (\n    input wire clk_in,      // input clock with frequency 100MHz\n    input wire rst,         // active-high synchronous reset\n    output reg  clk_50MHz,   // output clock with frequency 50MHz\n    output reg  clk_10MHz,   // output clock with frequency 10MHz\n    output reg  clk_1MHz     // output clock with frequency 1MHz\n);\n\n    // Divide-by-2 counter\n    always @(posedge clk_in) begin\n        if (rst)\n            clk_50MHz <= 0;\n        else\n            clk_50MHz <= ~clk_50MHz;\n    end\n\n    // Divide-by-10 counter (for 10MHz)\n    reg [2:0] cnt_10MHz;\n    always @(posedge clk_in) begin\n        if (rst) begin\n            cnt_10MHz  <= 0;\n            clk_10MHz  <= 0;\n        end else if (cnt_10MHz == 4) begin\n            cnt_10MHz  <= 0;\n            clk_10MHz  <= ~clk_10MHz;\n        end else begin\n            cnt_10MHz <= cnt_10MHz + 1;\n        end\n    end\n\n    // Divide-by-100 counter (for 1MHz)\n    reg [6:0] cnt_1MHz;\n    always @(posedge clk_in) begin\n        if (rst) begin\n            cnt_1MHz  <= 0;\n            clk_1MHz  <= 0;\n        end else if (cnt_1MHz == 49) begin\n            cnt_1MHz  <= 0;\n            clk_1MHz  <= ~clk_1MHz;\n        end else begin\n            cnt_1MHz <= cnt_1MHz + 1;\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a FSM detection circuit that detects a single bit input IN. When the input is 10011, output MATCH is high, and MATCH is 0 in other cases.",
        "ollama_output_code": ""
    },
    {
        "input_prompt": "Implement a 64-bit Johnson counter (torsional ring counter), and cyclic state of the the similar 4-bit Johnson counter is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.",
        "ollama_output_code": "module johnson_counter_64 (\n    input  wire        clk,\n    input  wire        rst,\n    output reg [63:0]  q\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        q <= 64'b0;\n    else\n        q <= {~q[63], q[63:1]};\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement an 8bit booth-4 multiplier. ",
        "ollama_output_code": "module booth_4_multiplier (\n    input [7:0] A,        // 8-bit multiplicand (signed)\n    input [7:0] B,        // 8-bit multiplier (signed)\n    output reg [15:0] P    // 16-bit product\n);\n\n    // ... (omitted for brevity) ..."
    },
    {
        "input_prompt": "Implement the design of 4bit unsigned number pipeline multiplier.",
        "ollama_output_code": "module pipeline_multiplier_4bit (\n    input  wire [3:0] A,        // 4-bit input A\n    input  wire [3:0] B,        // 4-bit input B\n    input  wire clk,             // Clock signal\n    input  wire rst,             // Reset signal\n    output reg [7:0] P          // 8-bit output product\n);\n\n    // Intermediate signals for pipelining\n    reg [7:0] partial_0, partial_1, partial_2, partial_3;\n    reg [7:0] sum_0, sum_1, sum_2;\n\n    // Stage 1: Generate partial products for each bit of B and A\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_0 <= 0;\n        end else begin\n            partial_0 <= {4'b0, A} & {8{B[0]}};  // Partial product for bit 0 of B\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_1 <= 0;\n        end else begin\n            partial_1 <= {3'b0, A, 1'b0} & {8{B[1]}};  // Partial product for bit 1 of B (shifted by 1)\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_2 <= 0;\n        end else begin\n            partial_2 <= {2'b0, A, 2'b0} & {8{B[2]}};  // Partial product for bit 2 of B (shifted by 2)\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_3 <= 0;\n        end else begin\n            partial_3 <= {1'b0, A, 3'b0} & {8{B[3]}};  // Partial product for bit 3 of B (shifted by 3)\n        end\n    end\n\n    // Stage 2: Add partial products to get sum_0\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum_0 <= 0;\n        end else begin\n            sum_0 <= partial_0 + partial_1;  // Add first two partial products\n        end\n    end\n\n    // Stage 3: Add the next partial product to sum_0 to get sum_1\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum_1 <= 0;\n        end else begin\n            sum_1 <= sum_0 + partial_2;  // Add partial product 2\n        end\n    end\n\n    // Stage 4: Add the final partial product to sum_1 to get sum_2\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum_2 <= 0;\n        end else begin\n            sum_2 <= sum_1 + partial_3;  // Add partial product 3\n        end\n    end\n\n    // Output product: Assign the final sum to the output product P\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            P <= 0;\n        end else begin\n            P <= sum_2;  // Assign final sum as output product\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a multi-bit MUX synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 B clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 B clock cycles.",
        "ollama_output_code": "module mux_synchronizer #(\n    parameter WIDTH = 8  // Set the width of the data bus (default 8 bits)\n)(\n    input wire clk,           // Clock signal\n    input wire rst,           // Reset signal\n    input wire [WIDTH-1:0] data_in,  // Data input to be synchronized\n    input wire data_en,      // Enable signal for data synchronization\n    output reg [WIDTH-1:0] data_out  // Synchronized data output\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sync_data_1 <= 0;\n            sync_data_2 <= 0;\n            data_en_sync <= 0;\n            data_out <= 0;\n        end else begin\n            // Synchronizing the enable signal (data_en) across clock cycles\n            data_en_sync <= {data_en_sync[0], data_en};  // Two flip-flop synchronizer\n\n            // If data_en is stable high (at least 3 cycles), sync data_in\n            if (data_en_sync == 2'b11) begin\n                sync_data_1 <= data_in;  // Store data_in in first stage\n                sync_data_2 <= sync_data_1;  // Transfer to second stage\n            end\n\n            // Output the synchronized data from the second stage\n            data_out <= sync_data_2;\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a module for parallel-to-serial conversion, where every four input bits are converted to one output bit. The output signal valid_in indicates the validity of the input at that time.",
        "ollama_output_code": "module parallel_to_serial (\n    input wire clk,\n    input wire rst,\n    input wire [3:0] data_in,\n    input wire valid_in,\n    output reg serial_out,\n    output reg valid_out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        data_buffer <= 4'b0;\n        count <= 3'b0;\n        serial_out <= 1'b0;\n        valid_out <= 1'b0;\n    end else if (valid_in) begin\n        if (count == 3'b0) begin\n            // Load the input data into the buffer\n            data_buffer <= data_in;\n            valid_out <= 1'b1;\n        end else begin\n            // Shift the data out serially\n            serial_out <= data_buffer[3];  // Take the MSB for output\n            data_buffer <= {data_buffer[2:0], 1'b0}; // Shift the data left\n        end\n\n        // Increment counter to keep track of the shifts\n        count <= count + 1;\n\n        // When all 4 bits have been sent, reset counter and valid_out\n        if (count == 3'b011) begin\n            count <= 3'b0;\n            valid_out <= 1'b0;\n        end\n    end else begin\n        // If valid_in is low, do not output valid data\n        valid_out <= 1'b0;\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement the design where a single clock-cycle width pulse(data_in) is extracted from the A clock(fast) domain and a new single clock-width pulse (data_out) will be created in the clock domain B(slow).",
        "ollama_output_code": "module pulse_synchronizer (\n    input wire clk_a,            // Fast clock A\n    input wire clk_b,            // Slow clock B\n    input wire rst,              // Reset signal\n    input wire data_in,          // Single clock-width pulse in the A domain\n    output reg data_out          // Single clock-width pulse in the B domain\n);\n\nalways @(posedge clk_a or posedge rst) begin\n    if (rst) begin\n        sync_1 <= 1'b0;\n        sync_2 <= 1'b0;\n    end else begin\n        sync_1 <= data_in;  // First stage synchronizer\n        sync_2 <= sync_1;    // Second stage synchronizer\n    end\nend\n\nalways @(posedge clk_b or posedge rst) begin\n    if (rst) begin\n        data_out <= 1'b0;\n    end else begin\n        // Detect rising edge in the B domain and generate a pulse\n        if (sync_2 && !sync_1) begin\n            data_out <= 1'b1;  // Generate pulse\n        end else begin\n            data_out <= 1'b0;  // Clear pulse after one clock cycle\n        end\n    end\nend\nendmodule"
    },
    {
        "input_prompt": "Implement a true dual-port RAM with a depth of 8 and a bit width of 4 bits, with all data initialized to 0000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is valid, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is valid, data is written to the corresponding position through the write_addr signal and write-data signal.",
        "ollama_output_code": "module true_dual_port_ram (\n    input wire clk,\n    input wire rst,\n    input wire read_en,\n    input wire [2:0] read_addr,\n    output reg [3:0] read_data,\n    input wire write_en,\n    input wire [2:0] write_addr,\n    input wire [3:0] write_data\n);\n\n    // 8x4-bit memory array initialized to zero (4-bit wide, 8-deep)\n    reg [3:0] mem [7:0];\n\n    // Synchronous reset to initialize memory to 0\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            for (i = 0; i < 8; i = i + 1) begin\n                mem[i] <= 4'b0000;\n            end\n        end else begin\n            // Perform write operation when write_en is high\n            if (write_en) begin\n                mem[write_addr] <= write_data;\n            end\n        end\n    end\n\n    // Asynchronous read operation\n    always @(*) begin\n        if (read_en) begin\n            read_data = mem[read_addr];  // Output the data at the specified read address\n        end else begin\n            read_data <= 4'b0000;         // If read_en is not enabled, output 0000\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.The register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).The most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.",
        "ollama_output_code": "module right_shifter (\n    input clk,\n    input d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= (q >> 1);  // Right shift\n        q[7] <= d;      // Insert new bit at MSB\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a series-parallel conversion circuit, the input end inputs single bit data, and when the module receives 6 input data, the output end outputs the 6bit data after splicing. The module adopts the valid-ready two-way handshake mechanism between the input and upstream, and the valid-only handshake mechanism between the output and downstream. During data concatenation, the received data is placed in the lower part of data_b.",
        "ollama_output_code": "module serial_to_parallel_6bit (\n    input clk,\n    input rst,\n\n    // Input side (valid-ready handshake)\n    input        data_in,\n    input        valid_in,\n    output reg   ready_out,\n\n    // Output side (valid-only handshake)\n    output reg [5:0] data_out,\n    output reg       valid_out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        data_b     <= 6'd0;\n        bit_count  <= 3'd0;\n        valid_out  <= 1'b0;\n        ready_out  <= 1'b1;\n        data_out   <= 6'd0;\n    end else begin\n        valid_out <= 1'b0;  // Default: no valid output\n\n        if (valid_in && ready_out) begin\n            // Shift incoming bit into data_b (LSB first)\n            data_b <= {data_in, data_b[5:1]};\n            bit_count <= bit_count + 1;\n\n            if (bit_count == 3'd5) begin\n                data_out <= {data_in, data_b[5:1]}; // Final 6-bit vector\n                valid_out <= 1'b1;\n                bit_count <= 3'd0;\n                data_b <= 6'd0;\n            end\n        end\n\n        // Always ready unless currently outputting\n        ready_out <= !(valid_in && bit_count == 3'd5);\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a signal generator module, select the signal wave_choise according to the waveform to send out the corresponding waveform: wave_choice=0, send out the square wave signal; wave_choice=1, sends a sawtooth signal; wave_choice=2, the triangular wave signal is emitted.",
        "ollama_output_code": "module signal_generator (\n    input clk,\n    input rst,\n    input [1:0] wave_choice,        // 0: Square, 1: Sawtooth, 2: Triangle\n    output reg [7:0] signal_out\n);\n\n  always @(posedge clk or posedge rst) begin\n    case (wave_choice)\n        2'b00: square_wave(signal_out, wave_choice); // Square wave\n        2'b01: sawtooth_wave(signal_out, wave_choice); // Sawtooth wave\n        2'b10: triangle_wave(signal_out, wave_choice); // Triangular wave\n        default: signal_out <= 8'd0;\n    endcase\n  end\n\nendmodule\n\nalways @* begin\n  case (wave_choice)\n    2'b00: square_wave = (counter < 128) ? 8'd255 : 8'd0; // Square wave\n    2'b01: sawtooth_wave = counter; // Sawtooth wave\n    2'b10: triangle_wave = counter; // Triangular wave\n    default: signal_out <= 8'd0;\n  endcase\nend"
    },
    {
        "input_prompt": "Implement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged.",
        "ollama_output_code": "module traffic_light_controller (\n    input clk,\n    input rst,\n    input pedestrian_button,\n    output reg red,\n    output reg yellow,\n    output reg green\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= GREEN;\n        counter <= 0;\n        shorten_green <= 0;\n        green_time <= 60;\n    end else begin\n        state <= next_state;\n\n        // Detect pedestrian button press during green\n        if (state == GREEN && pedestrian_button && counter < 51) begin\n            shorten_green <= 1;\n            green_time <= 10;\n        end else if (state == GREEN && !pedestrian_button) begin\n            shorten_green <= 0;\n            green_time <= 60;\n        end\n\n        // Counter logic\n        if (state != next_state) begin\n            counter <= 0; // Reset the counter on state change\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nalways @(*) begin\n    next_state = state;\n\n    case (state)\n        GREEN: begin\n            if ((shorten_green && counter >= 10) || (!shorten_green && counter >= 60))\n                next_state = YELLOW;\n        end\n        YELLOW: begin\n            if (counter >= 5)\n                next_state = RED;\n        end\n        RED: begin\n            if (counter >= 10)\n                next_state = GREEN;\n        end\n        default: next_state = INVALID; // Handle the invalid state\n    endcase\nend\n\nalways @(*) begin\n    case (state)\n        GREEN: begin\n            green  = 1;\n            yellow = 0;\n            red    = 0;\n        end\n        YELLOW: begin\n            green  = 0;\n            yellow = 1;\n            red    = 0;\n        end\n        RED: begin\n            green  = 0;\n            yellow = 0;\n            red    = 1;\n        end\n        default: begin // Add default case for undefined state\n            green  = 0;\n            yellow = 0;\n            red    = 0;\n        end\n    endcase\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output.",
        "ollama_output_code": "module width_converter_8to16 (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    input valid_in,\n    output reg [15:0] data_out,\n    output reg valid_out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        temp <= 8'd0;\n        data_out <= 16'd0;\n        has_first_byte <= 1'b0;\n        valid_out <= 1'b0;\n    end else begin\n        valid_out <= 1'b0; // default, will be set high when output is ready\n\n        if (valid_in) begin\n            if (!has_first_byte) begin\n                // Store the first byte\n                temp <= data_in;\n                has_first_byte <= 1'b1;\n            end else begin\n                // Combine and output 16-bit data\n                data_out <= {temp, data_in}; // high byte first\n                valid_out <= 1'b1;\n                has_first_byte <= 1'b0;\n            end\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a ripple 64 bit adder, which is divided into 4 sections to achieve 4-stage pipeline.",
        "ollama_output_code": "module ripple_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum0,\n    output sum1,\n    output sum2,\n    output sum3,\n    output carry\n);\n\nsection0 (a, b, cin, sum0, carry) {\n    assign sum0 = a + b + cin;\n    assign carry = a & b & cin;\n}\n\nsection1 (sum0, sum1, carry) {\n    assign sum1 = sum0 + carry;\n}\n\nsection2 (sum1, sum2, carry) {\n    assign sum2 = sum1 + carry;\n}\n\nsection3 (sum2, sum3, carry) {\n    assign sum3 = sum2 + carry;\n}"
    },
    {
        "input_prompt": "Implement an ALU for 32bit MIPS-ISA CPU.",
        "ollama_output_code": "module alu_32bit (\n    input [31:0] A,       // Operand 1\n    input [31:0] B,       // Operand 2\n    input [4:0] shamt,    // Shift amount (used for shift ops)\n    input [3:0] alu_ctrl, // ALU control signal\n    output reg [31:0] result,\n    output zero           // Zero flag\n);\n\nalways @(*) begin\n    case (alu_ctrl)\n        4'b0000: result = A & B;                      // AND\n        4'b0001: result = A | B;                      // OR\n        4'b0010: result = A + B;                      // ADD\n        4'b0110: result = A - B;                      // SUB\n        4'b0111: result = ($signed(A) < $signed(B)) ? 32'd1 : 32'd0; // SLT\n        4'b1000: result = (A < B) ? 32'd1 : 32'd0;    // SLTU\n        4'b1100: result = ~(A | B);                   // NOR\n        4'b0011: result = A ^ B;                      // XOR\n        4'b1001: result = B << shamt;                 // SLL\n        4'b1010: result = B >> shamt;                 // SRL\n        4'b1011: result = $signed(B) >>> shamt;       // SRA\n        default: result = 32'd0;\n    endcase\nend"
    }
]