[
    {
        "input_prompt": "Implement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of a multiplied by b will be accumulated in this register, and the c shows the value of the register.",
        "ollama_output_code": "module MAC_PE (\n    input               clk     ,\n    input               rst_n   ,\n    input       [31:0]  a       ,\n    input       [31:0]  b       ,\n    output reg [31:0]  c         );\n\n    reg [31:0] acc;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            acc <= 4'h0;\n        end else begin\n            acc <= acc + a * b;\n        end\n    end\n\n    always @(*) begin\n        c = acc;\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement the design of unsigned 8bit multiplier based on pipelining processing.",
        "ollama_output_code": "module pipelined_multiplier_8bit (\n    input clk,\n    input rst,\n    input [7:0] A,\n    input [7:0] B,\n    output reg [15:0] P\n);\n\n    // Stage 1: Register Inputs\n    reg [7:0] A_reg1, B_reg1;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            A_reg1 <= 8'd0;\n            B_reg1 <= 8'd0;\n        end else begin\n            A_reg1 <= A;\n            B_reg1 <= B;\n        end\n    end\n\n    // Stage 2: Generate Partial Products\n    reg [15:0] partial_products [7:0];\n    integer i;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            for (i = 0; i < 8; i = i + 1)\n                partial_products[i] <= 16'd0;\n        end else begin\n            for (i = 0; i < 8; i = i + 1)\n                partial_products[i] <= (B_reg1[i]) ? ({8'd0, A_reg1} << i) : 16'd0;\n        end\n    end\n\n    // Stage 3: Sum partials using tree adder (two levels)\n    reg [15:0] sum1, sum2, sum3, sum4;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum1 <= 16'd0;\n            sum2 <= 16'd0;\n            sum3 <= 16'd0;\n            sum4 <= 16'd0;\n        end else begin\n            sum1 <= partial_products[0] + partial_products[1];\n            sum2 <= partial_products[2] + partial_products[3];\n            sum3 <= partial_products[4] + partial_products[5];\n            sum4 <= partial_products[6] + partial_products[7];\n        end\n    end\n\n    // Stage 4: Final Addition\n    reg [15:0] final_sum;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            final_sum <= 16'd0;\n            P <= 16'd0;\n        end else begin\n            final_sum <= (sum1 + sum2) + (sum3 + sum4);\n            P <= final_sum;\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement the design of unsigned 16bit multiplier based on shifting and adding opration..",
        "ollama_output_code": "module shift_add_multiplier_16bit (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] A,\n    input [15:0] B,\n    output reg [31:0] P,\n    output reg done\n);\n\n    reg [15:0] multiplicand;\n    reg [15:0] multiplier;\n    reg [31:0] product;\n    reg [4:0] count; // log2(16) = 4, use 5 bits for safety\n    reg busy;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            P <= 32'd0;\n            product <= 32'd0;\n            multiplicand <= 16'd0;\n            multiplier <= 16'd0;\n            count <= 5'd0;\n            busy <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            if (start && !busy) begin\n                multiplicand <= A;\n                multiplier <= B;\n                product <= 32'd0;\n                count <= 5'd0;\n                busy <= 1'b1;\n                done <= 1'b0;\n            end else if (busy) begin\n                if (multiplier[0] == 1'b1)\n                    product <= product + {16'd0, multiplicand};\n\n                multiplicand <= multiplicand << 1;\n                multiplier <= multiplier >> 1;\n                count <= count + 1;\n\n                if (count == 15) begin\n                    busy <= 1'b0;\n                    done <= 1'b1;\n                    P <= product + ((multiplier[0]) ? {16'd0, multiplicand} : 32'd0);\n                end\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a 16-bit divider module, dividend is 16-bit and divider is 8-bit. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.",
        "ollama_output_code": "module divider_16by8 (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] dividend,\n    input [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [7:0] remainder,\n    output reg done\n);\n\n    reg [4:0] count;\n    reg [15:0] dividend_reg;\n    reg [7:0] divisor_reg;\n    reg [7:0] rem;\n    reg [15:0] quot;\n    reg busy;\n\n    reg [7:0] next_rem;\n    reg [15:0] next_quot;\n    reg [15:0] next_dividend;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            quotient <= 16'd0;\n            remainder <= 8'd0;\n            dividend_reg <= 16'd0;\n            divisor_reg <= 8'd0;\n            rem <= 8'd0;\n            quot <= 16'd0;\n            count <= 5'd0;\n            busy <= 0;\n            done <= 0;\n        end else begin\n            if (start && !busy) begin\n                if (divisor != 0) begin\n                    dividend_reg <= dividend[15:8];\n                    divisor_reg <= divisor;\n                    rem <= 8'd0;\n                    quot <= 16'd0;\n                    count <= 5'd16;\n                    busy <= 1;\n                    done <= 0;\n                end else begin\n                    quotient <= 16'd0;\n                    remainder <= dividend[7:0];\n                    done <= 1;\n                end\n            end else if (busy) begin\n                next_rem = {rem[6:0], dividend_reg[15]};\n                next_dividend = {dividend_reg[14:0], 1'b0};\n\n                if (next_rem >= divisor_reg) begin\n                    next_rem = next_rem - divisor_reg;\n                    next_quot = {quot[14:0], 1'b1};\n                end else begin\n                    next_quot = {quot[14:0], 1'b0};\n                end\n\n                rem <= next_rem;\n                quot <= next_quot;\n                dividend_reg <= next_dividend;\n                count <= count - 1;\n\n                if (count == 5'd1) begin\n                    quotient <= next_quot;\n                    remainder <= next_rem;\n                    busy <= 0;\n                    done <= 1;\n                end\n            end else begin\n                done <= 0;\n            end\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a module to achieve serial input data accumulation output, input input 8bit data, whenever the module receives 4 input data, the output outputs 4 received data accumulation results. The input and output interfaces interact with the upstream and downstream using the valid-ready two-way handshake mechanism. When both upstream and downstream are required to be able to transmit at full speed, there is no bubble in data transmission, and no additional performance loss can be caused due to the design of this module.",
        "ollama_output_code": "module accumulator_4x8bit (\n    input clk,\n    input rst,\n\n    // Input interface\n    input [7:0] data_in,\n    input       valid_in,\n    output reg  ready_out,\n\n    // Output interface\n    output reg [15:0] data_out,  // Max sum = 4 x (2^8 - 1) + 4 = 61 * 4 + 4 = 248\n    output reg       valid_out,\n    input            ready_in\n);\n\n    reg [15:0] sum;      // Accumulator (up to 248)\n    reg [3:0] count;    // Count of inputs received (0 to 4)\n\n    // Input ready logic\n    always @(*) begin\n        // Accept input when output is not blocking\n        ready_out = (!valid_out) || (valid_out && ready_in);\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum       <= 16'h0;\n            count     <= 4'b0;\n            data_out  <= 16'h0;\n            valid_out <= 1'b0;\n        end else begin\n            // Clear valid_out when downstream has accepted output\n            if (valid_out && ready_in) begin\n                valid_out <= 1'b0;\n            end\n\n            // Accept new input\n            if (valid_in && ready_out) begin\n                sum <= sum + {4'b0, data_in};  // Zero-extend data_in to 16 bits\n                count <= count + 1;\n\n                if (count == 5) begin\n                    data_out <= sum + {4'b0, data_in};  // Final sum\n                    valid_out <= 1'b1;\n                    sum <= 16'h0;\n                    count <= 4'b0;\n                end\n            end\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a module of an 8 bit adder in gate level.",
        "ollama_output_code": "module adder_8bit (\n    input a,\n    input b,\n    input cin,\n    output reg [7:0] sum,\n    output reg cout\n);\n\n  assign sum[0] = a[0] + b[0] + cin;\n  assign sum[1] = a[1] + sum[0];\n  assign sum[2] = a[2] + sum[1];\n  assign sum[3] = a[3] + sum[2];\n  assign sum[4] = a[4] + sum[3];\n  assign sum[5] = a[5] + sum[4];\n  assign sum[6] = a[6] + sum[5];\n  assign sum[7] = a[7] + sum[6] + cin;\n\n  assign cout = sum[7] > 1'b1;\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a 16-bit full adder.",
        "ollama_output_code": "module full_adder (\n    input [15:0] a,\n    input [15:0] b,\n    input cin,\n    output [16:0] sum,\n    output cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a carry lookahead 32 bit adder based on CLAs.",
        "ollama_output_code": "module cla_32bit_adder (\n    input [31:0] a,\n    input [31:0] b,\n    input cin,\n    output reg [31:0] sum,\n    output reg [31:0] carry\n);\n\n  wire g0 = a[0] ^ b[0];\n  wire g1 = (a[0] & b[0]) | (cin & (~a[0] & ~b[0]));\n  assign carry[0] = g1;\n  assign sum[0] = a[0] ^ b[0] ^ cin;\n\n  wire [7:0] g2;\n  assign g2 = {(a[1:0] & b[1:0]) | (cin & (~a[1:0] & ~b[1:0]))};\n  wire g3 = a[2] ^ b[2] ^ cin & g1;\n  assign carry[1:0] = g3;\n  assign sum[1:0] = {sum[1:0], (a[1:0] + b[1:0]) ^ cin};\n\n  wire [15:0] g4;\n  assign g4 = {(a[3:2] & b[3:2]) | (cin & (~a[3:2] & ~b[3:2]))};\n  wire g5 = a[4] ^ b[4] ^ cin & g3;\n  wire g6 = (g2[0] ^ b[4]) & g5;\n  assign carry[4:1] = {g5, g6};\n  assign sum[4:1] = {sum[4:1], (a[3:2] + b[3:2]) ^ cin};\n\n  wire [31:0] g7;\n  assign g7 = {(a[15:8] & b[15:8]) | (cin & (~a[15:8] & ~b[15:8]))};\n  wire g8 = a[16] ^ b[16] ^ cin & carry[3];\n  wire g9 = (g4[0] ^ b[16]) & g8;\n  assign carry[16:8] = {g8, g9};\n  assign sum[16:8] = {sum[16:8], (a[15:8] + b[15:8]) ^ cin};\n\n  wire g10 = a[32] ^ b[32] ^ cin & carry[17];\n  assign carry[32] = g10;\n  assign sum[32] = (a[32] + b[32]) ^ cin;\nendmodule"
    },
    {
        "input_prompt": "Implement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16,parameter WIDTH = 8). ",
        "ollama_output_code": "module async_fifo #(\n    parameter DEPTH = 16,\n    parameter WIDTH = 8\n)(\n    input                   rst,\n\n    // Write interface\n    input                   clk_wr,\n    input       [WIDTH-1:0] data_in,\n    input                   wr_en,\n    output                  full,\n\n    // Read interface\n    input                   clk_rd,\n    output      [WIDTH-1:0] data_out,\n    input                   rd_en,\n    output                  empty\n);\n\n    localparam ADDR_WIDTH = $clog2(DEPTH);\n\n    // FIFO memory\n    reg [WIDTH-1:0] mem [0:DEPTH-1];\n\n    // Write pointer (binary and gray)\n    reg [ADDR_WIDTH:0] wr_ptr_bin = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray_sync1 = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray_sync2 = 0;\n\n    // Read pointer (binary and gray)\n    reg [ADDR_WIDTH:0] rd_ptr_bin = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray_sync1 = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray_sync2 = 0;\n\n    wire [ADDR_WIDTH:0] wr_addr = wr_ptr_bin;\n    wire [ADDR_WIDTH:0] rd_addr = rd_ptr_bin;\n\n    // === WRITE DOMAIN ===\n    always @(posedge clk_wr or posedge rst) begin\n        if (rst) begin\n            wr_ptr_bin  <= 0;\n            wr_ptr_gray <= 0;\n        end else if (wr_en && !full) begin\n            mem[wr_ptr_bin[ADDR_WIDTH-1:0]] <= data_in;\n            wr_ptr_bin  <= wr_ptr_bin + 1;\n            wr_ptr_gray <= (wr_ptr_bin + 1) ^ ((wr_ptr_bin + 1) >> 1);  // Binary to Gray\n        end\n    end\n\n    // Synchronize read pointer to write domain\n    always @(posedge clk_wr or posedge rst) begin\n        if (rst) begin\n            rd_ptr_gray_sync1 <= 0;\n            rd_ptr_gray_sync2 <= 0;\n        end else begin\n            rd_ptr_gray_sync1 <= rd_ptr_gray;\n            rd_ptr_gray_sync2 <= rd_ptr_gray_sync1;\n        end\n    end\n\n    // FULL condition\n    assign full = (wr_ptr_gray == {~rd_ptr_gray_sync2[ADDR_WIDTH:ADDR_WIDTH-1], rd_ptr_gray_sync2[ADDR_WIDTH-2:0]});\n\n    // === READ DOMAIN ===\n    always @(posedge clk_rd or posedge rst) begin\n        if (rst) begin\n            rd_ptr_bin  <= 0;\n            rd_ptr_gray <= 0;\n        end else if (rd_en && !empty) begin\n            rd_ptr_bin  <= rd_ptr_bin + 1;\n            rd_ptr_gray <= (rd_ptr_bin + 1) ^ ((rd_ptr_bin + 1) >> 1);  // Binary to Gray\n        end\n    end\n\n    assign data_out = mem[rd_ptr_bin[ADDR_WIDTH-1:0]];\n\n    // Synchronize write pointer to read domain\n    always @(posedge clk_rd or posedge rst) begin\n        if (rst) begin\n            wr_ptr_gray_sync1 <= 0;\n            wr_ptr_gray_sync2 <= 0;\n        end else begin\n            wr_ptr_gray_sync1 <= wr_ptr_gray;\n            wr_ptr_gray_sync2 <= wr_ptr_gray_sync1;\n        end\n    end\n\n    // EMPTY condition\n    assign empty = (rd_ptr_gray == wr_ptr_gray_sync2);\n\nendmodule"
    },
    {
        "input_prompt": "Implement a module of perpetual calendar. The output port Secs counts from 0 to 59, and when the Secs count reaches 59, the output port Mins increases by one and stops counting until minute=59. When the Mins count reaches 59, the output port Hours increases by one and stops counting until Hours=24.",
        "ollama_output_code": "module perpetual_calendar (\n    input clk,\n    input rst,\n    output reg [5:0] Secs,\n    output reg [5:0] Mins,\n    output reg [4:0] Hours\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        Secs <= 0;\n        Mins <= 0;\n        Hours <= 0;\n    end else begin\n        if (Secs == 59) begin\n            Secs <= 0;\n            if (Mins == 59) begin\n                Mins <= 0;\n                if (Hours == 23)\n                    Hours <= 0;\n                else\n                    Hours <= Hours + 1;\n            end else begin\n                Mins <= Mins + 1;\n            end\n        end else begin\n            Secs <= Secs + 1;\n        end\n    end\nend"
    },
    {
        "input_prompt": "Implement a module of a counter design that requires counting from 4 'b0000 to 4' d12. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is invalid.",
        "ollama_output_code": "module controlled_counter (\n    input        clk,\n    input        rst,\n    input        valid_count,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'd0;\n    end else if (valid_count) begin\n        if (count == 4'd12)\n            count <= 4'd0;\n        else\n            count <= count + 1;\n    end\nend"
    },
    {
        "input_prompt": "Implement a module for edge detection, there is a slowly changing 1 bit signal a. When the rising edge of signal a is detected, the indicating signal rise is given; when the falling edge of signal A is shown, the indicating signal down is given. rise and down are high on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.",
        "ollama_output_code": "module edge_detector (\n    input  wire clk,\n    input  wire rst,\n    input  wire a,\n    output reg  rise,\n    output reg  down\n    );\n\n    reg a_d;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            a_d <= 0;\n            rise <= 0;\n            down <= 0;\n        end else begin\n            rise <= (~a_d) & a;\n            down <= a_d & (~a);\n            a_d <= a;\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.",
        "ollama_output_code": "module freq_divider (\n    input  wire clk_in,      // 100MHz input clock\n    input  wire rst,         // Active-high synchronous reset\n    output reg  clk_50MHz,   // 繩2 output (50MHz)\n    output reg  clk_10MHz,   // 繩10 output (10MHz)\n    output reg  clk_1MHz     // 繩100 output (1MHz)\n);\n\n// Divide-by-2 counter\nalways @(posedge clk_in) begin\n    if (rst)\n        clk_50MHz <= 0;\n    else\n        clk_50MHz <= ~clk_50MHz;\nend\n\n// Divide-by-10 counter (for 10MHz)\nreg [3:0] cnt_10MHz;\nalways @(posedge clk_50MHz) begin\n    if (rst) begin\n        cnt_10MHz <= 4'b0;\n        clk_10MHz <= 0;\n    end else if (cnt_10MHz == 5) begin\n        cnt_10MHz <= 4'b0;\n        clk_10MHz <= ~clk_10MHz;\n    end else begin\n        cnt_10MHz <= cnt_10MHz + 1;\n    end\nend\n\n// Divide-by-100 counter (for 1MHz)\nreg [6:0] cnt_1MHz;\nalways @(posedge clk_10MHz) begin\n    if (rst) begin\n        cnt_1MHz <= 7'b0;\n        clk_1MHz <= 0;\n    end else if (cnt_1MHz == 98) begin\n        cnt_1MHz <= 7'b0;\n        clk_1MHz <= ~clk_1MHz;\n    end else begin\n        cnt_1MHz <= cnt_1MHz + 1;\n    end\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement a FSM detection circuit that detects a single bit input IN. When the input is 10011, output MATCH is high, and MATCH is 0 in other cases.",
        "ollama_output_code": "module fsm_10011_detector (\n    input  wire clk,     // Clock\n    input  wire rst,     // Active-high synchronous reset\n    input  wire IN,      // Serial input\n    output reg  MATCH    // High for 1 clk when \"10011\" is detected\n);\n\n    typedef enum logic [2:0] {S0, S1, S2, S3, S4, S5} state_t;\n    state_t state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = IN ? S1 : S0;\n            S1: next_state = IN ? S2 : S0;\n            S2: next_state = IN ? S3 : S0;\n            S3: next_state = IN ? S4 : S0;\n            S4: next_state = IN ? S5 : S2;\n            S5: next_state = IN ? S1 : S2;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            MATCH <= 0;\n        else\n            MATCH <= (state == S5);\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a 64-bit Johnson counter (torsional ring counter), and cyclic state of the the similar 4-bit Johnson counter is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.",
        "ollama_output_code": "module johnson_counter_64 (\n    input  wire        clk,    // Clock\n    input  wire        rst,    // Active-high synchronous reset\n    output reg [63:0]  q       // 64-bit Johnson counter output\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        q <= 64'b0;  // Reset to all zeros\n    else\n        q <= {~q[63], q[62:0]};  // Shift right and feed inverted MSB to LSB\nend\n\nalways @(posedge clk) begin\n    if (q == 64'b1_1111_1100_1000_0000 || q == 64'b0_0001_0011_1111_1110_1100_1000_1111)\n        $display(\"Cyclic State Reached\");\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement an 8bit booth-4 multiplier. ",
        "ollama_output_code": "module booth_4_multiplier (\n    input [7:0] A,        // 8-bit multiplicand (signed)\n    input [7:0] B,        // 8-bit multiplier (signed)\n    output reg [15:0] P    // 16-bit product\n);\n\n    reg [7:0] M;        // Register for A\n    reg [7:0] Q;        // Register for B\n    reg [7:0] Q_1;      // Q-1, previous least significant bit of Q\n    reg [15:0] A_neg;   // Negative A for subtraction\n    integer i;\n\n    always @* begin\n        M = A;\n        Q = B;\n        Q_1 = 0;\n        P = 0;  // Clear product register\n\n        A_neg = {8'b0, M} + 1;  // Extend M to 16 bits before negating\n\n        for (i = 0; i < 8; i = i + 1) begin\n            case ({Q[0], Q_1} & 9'b000000011)  // Mask to ensure the proper bit-width\n                9'b00000001: P = P + {8'b0, M};    // Add M to product (extend M to 16 bits)\n                9'b00000010: P = P - {8'b0, M};    // Subtract M from product (extend M to 16 bits)\n                default: ;           // Do nothing for 00 or 11\n            endcase\n\n            {Q_1, Q} = {P[0], Q[7:1], 1'b0, 7'b0};  // Move Q bits to the right and ensure 16-bit width\n            P = {P[15], P[15:1]};       // Extend the sign bit of P to the left\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement the design of 4bit unsigned number pipeline multiplier.",
        "ollama_output_code": "module pipeline_multiplier_4bit (\n    input  wire [3:0] A,        // 4-bit input A\n    input  wire [3:0] B,        // 4-bit input B\n    input  wire clk,             // Clock signal\n    input  wire rst,             // Reset signal\n    output reg [7:0] P          // 8-bit output product\n);\n\n    reg [7:0] partial_0, partial_1, partial_2, partial_3, partial_4;\n    reg [7:0] sum_0, sum_1, sum_2, sum_3, sum_4;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_0 <= 0;\n        end else begin\n            partial_0 <= {4'b0, A} & {8{B[0]}};\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_1 <= 0;\n        end else begin\n            partial_1 <= {3'b0, A, 1'b0} & {8{B[1]}};\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_2 <= 0;\n        end else begin\n            partial_2 <= {2'b0, A, 2'b0} & {8{B[2]}};\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_3 <= 0;\n        end else begin\n            partial_3 <= {1'b0, A, 3'b0} & {8{B[3]}};\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_4 <= 0;\n        end else begin\n            partial_4 <= {1'b0, A} & {8{B[3]}};  // Add the same product of B[3] again for 4-bit multiplication\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum_0 <= 0;\n        end else begin\n            sum_0 <= partial_0 + partial_1;\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum_1 <= 0;\n        end else begin\n            sum_1 <= sum_0 + partial_2;\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum_2 <= 0;\n        end else begin\n            sum_2 <= sum_1 + partial_3;\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum_3 <= 0;\n        end else begin\n            sum_3 <= sum_2 + partial_4;\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            P <= 0;\n        end else begin\n            P <= sum_3;\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a multi-bit MUX synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 B clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 B clock cycles.",
        "ollama_output_code": "module mux_synchronizer #(\n    parameter WIDTH = 8  // Set the width of the data bus (default 8 bits)\n)(\n    input wire clk,           // Clock signal\n    input wire rst,           // Reset signal\n    input wire [WIDTH-1:0] data_in,  // Data input to be synchronized\n    input wire data_en,      // Enable signal for data synchronization\n    output reg [WIDTH-1:0] data_out  // Synchronized data output\n);\n\nreg [WIDTH-1:0] sync_data;   // Data storage register\nreg data_en_counter = 0;     // Counter to check if data_en is high for at least 3 cycles\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        sync_data <= 0;\n        data_en_counter <= 0;\n        data_out <= 0;\n    end else begin\n        if (data_en) begin\n            data_en_counter <= data_en_counter + 1;\n            if (data_en_counter >= 3) begin\n                sync_data <= data_in;\n                data_en_counter <= 0;\n            end\n        end else begin\n            data_en_counter <= 0;\n        end\n        data_out <= sync_data;\n    end\nend"
    },
    {
        "input_prompt": "Implement a module for parallel-to-serial conversion, where every four input bits are converted to one output bit. The output signal valid_in indicates the validity of the input at that time.",
        "ollama_output_code": "module parallel_to_serial (\n    input wire clk,\n    input wire rst,\n    input wire [3:0] data_in,\n    input wire valid_in,\n    output reg serial_out,\n    output reg valid_out\n);\n\n    reg [3:0] data_buffer;\n    reg [2:0] count;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_buffer <= 4'b0;\n            count <= 3'b0;\n            serial_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else if (valid_in) begin\n            if (count == 3'b0) begin\n                data_buffer <= data_in;\n                valid_out <= 1'b1;\n            end else begin\n                serial_out <= data_buffer[3];\n                data_buffer <= {data_buffer[2:0], 1'b0};\n                count <= count + 1;\n\n                if (count == 4) begin\n                    count <= 3'b0;\n                    valid_out <= 1'b0;\n                end\n            end\n        end else begin\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement the design where a single clock-cycle width pulse(data_in) is extracted from the A clock(fast) domain and a new single clock-width pulse (data_out) will be created in the clock domain B(slow).",
        "ollama_output_code": "module pulse_synchronizer (\n    input wire clk_a,            // Fast clock A\n    input wire clk_b,            // Slow clock B\n    input wire rst,              // Reset signal\n    input wire data_in,          // Single clock-width pulse in the A domain\n    output reg data_out          // Single clock-width pulse in the B domain\n);\n\n    // Synchronizer flip-flops\n    reg sync_1, sync_2;          // Synchronize the data_in signal from clk_a to clk_b\n\n    always @(posedge clk_a or posedge rst) begin\n        if (rst) begin\n            sync_1 <= 1'b0;\n            sync_2 <= 1'b0;\n        end else begin\n            sync_1 <= data_in;  // First stage synchronizer\n            sync_2 <= sync_1;    // Second stage synchronizer\n        end\n    end\n\n    // Generate pulse in the B domain\n    always @(posedge clk_b or posedge rst) begin\n        if (rst) begin\n            data_out <= 1'b0;\n        end else begin\n            // Detect rising edge in the B domain and generate a pulse\n            if (sync_2 && !sync_1) begin\n                data_out <= 1'b1;  // Generate pulse\n            end else begin\n                data_out <= 1'b0;  // Clear pulse after one clock cycle\n            end\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a true dual-port RAM with a depth of 8 and a bit width of 4 bits, with all data initialized to 0000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is valid, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is valid, data is written to the corresponding position through the write_addr signal and write-data signal.",
        "ollama_output_code": "module true_dual_port_ram (\n    input wire clk,\n    input wire rst,\n    input wire read_en,\n    input wire [1:0] read_addr,\n    output reg [3:0] read_data,\n    input wire write_en,\n    input wire [1:0] write_addr,\n    input wire [3:0] write_data\n);\n\nreg [3:0] mem [7:0];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        for (integer i = 0; i < 8; i = i + 1) begin\n            mem[i] <= 4'b0000;\n        end\n    end else begin\n        if (write_en) begin\n            mem[write_addr] <= write_data;\n        end\n    end\nend\n\nalways @(*) begin\n    if (read_en) begin\n        read_data <= mem[read_addr];\n    end\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.The register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).The most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.",
        "ollama_output_code": "module right_shifter (\n    input clk,\n    input d,\n    output reg [7:0] q\n    );\n\n    initial begin\n        q = 8'd0;\n    end\n\n    always @(posedge clk) begin\n        if(clk) begin\n            q <= (q >> 1);\n            q[7] <= d;\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a series-parallel conversion circuit, the input end inputs single bit data, and when the module receives 6 input data, the output end outputs the 6bit data after splicing. The module adopts the valid-ready two-way handshake mechanism between the input and upstream, and the valid-only handshake mechanism between the output and downstream. During data concatenation, the received data is placed in the lower part of data_b.",
        "ollama_output_code": "module serial_to_parallel_12bit (\n    input clk,\n    input rst,\n\n    // Input side (valid-ready handshake)\n    input        data_in,\n    input        valid_in,\n    output reg   ready_out,\n\n    // Output side (valid-only handshake)\n    output reg [11:0] data_out,\n    output reg       valid_out\n);\n\n    reg [11:0] data_b;\n    reg [3:0] bit_count;  // Counts from 0 to 12\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_b     <= 12'd0;\n            bit_count  <= 4'd0;\n            valid_out  <= 1'b0;\n            ready_out  <= 1'b1;\n            data_out   <= 12'd0;\n        end else begin\n            valid_out <= 1'b0;  // Default: no valid output\n\n            if (valid_in && ready_out) begin\n                // Shift incoming bit into data_b (LSB first)\n                data_b <= {data_in, data_b[11:1]};\n                bit_count <= bit_count + 1;\n\n                if (bit_count == 4'd12) begin\n                    data_out <= {data_in, data_b[11:1]}; // Final 12-bit vector\n                    valid_out <= 1'b1;\n                    bit_count <= 4'd0;\n                    data_b <= 12'd0;\n                end\n            end\n\n            // Always ready unless currently outputting\n            ready_out <= !(valid_in && bit_count == 4'd12);\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a signal generator module, select the signal wave_choise according to the waveform to send out the corresponding waveform: wave_choice=0, send out the square wave signal; wave_choice=1, sends a sawtooth signal; wave_choice=2, the triangular wave signal is emitted.",
        "ollama_output_code": "module signal_generator (\n    input clk,\n    input rst,\n    input [1:0] wave_choice,\n    output reg [7:0] signal_out\n);\n\nreg [7:0] counter;\nreg direction;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 8'd0;\n        signal_out <= 8'd0;\n        direction <= 1'b0;\n    end else begin\n        case (wave_choice)\n            2'b0: begin\n                counter <= counter + 1;\n                signal_out <= (counter < 128) ? 8'd255 : 8'd0;\n            end\n            2'b1: begin\n                counter <= counter + 1;\n                signal_out <= counter;\n            end\n            2'b10: begin\n                if (!direction) begin\n                    counter <= counter + 1;\n                    if (counter == 8'd255) direction <= 1;\n                end else begin\n                    counter <= counter - 1;\n                    if (counter == 8'd0) direction <= 0;\n                end\n                signal_out <= counter;\n            end\n        endcase\n    end\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged.",
        "ollama_output_code": "module traffic_light (\n    input clk,\n    input rst,\n    input pedestrian_button,\n    output reg red,\n    output reg yellow,\n    output reg green\n);\n\nlocalparam GREEN = 3'b000;\nlocalparam YELLOW = 3'b001;\nlocalparam RED = 3'b010;\nlocalparam STOP = 3'b111; // Invalid state for safety\n\nreg state, next_state;\nreg count_down;\nreg [2:0] green_time;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= GREEN;\n        count_down <= 60;\n        green_time <= 3'b000;\n    end else begin\n        case (state)\n            GREEN: begin\n                if (pedestrian_button && count_down > 10) begin\n                    count_down <= 10;\n                end\n                if (count_down == 60 || pedestrian_button) begin\n                    state <= YELLOW;\n                end\n            end\n            YELLOW: begin\n                if (count_down == 5) begin\n                    state <= RED;\n                end\n            end\n            RED: begin\n                if (count_down == 10) begin\n                    state <= GREEN;\n                end\n            end\n            default: state <= STOP; // Handle invalid states\n        endcase\n        count_down <= count_down - 1;\n        green_time <= green_time + 1;\n    end\nend\n\nalways @(*) begin\n    next_state = state;\n    case (state)\n        GREEN: begin\n            if ((green_time == 60 || pedestrian_button) && count_down < 51) begin\n                next_state <= YELLOW;\n            end\n        end\n        YELLOW: begin\n            if (count_down >= 5) begin\n                next_state <= RED;\n            end\n        end\n        RED: begin\n            if (count_down >= 10) begin\n                next_state <= GREEN;\n            end\n        end\n        default: next_state <= STOP; // Handle invalid states\n    endcase\nend\n\nassign {red, yellow, green} = state;\n\nendmodule"
    },
    {
        "input_prompt": "Implement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output.",
        "ollama_output_code": "module width_converter_8to16 (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    input valid_in,\n    output reg [15:0] data_out,\n    output reg valid_out\n);\n\n    reg temp;\n    reg first_byte;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            temp <= 8'd0;\n            data_out <= 16'd0;\n            first_byte <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            valid_out <= 1'b0;\n\n            if (valid_in) begin\n                if (!first_byte) begin\n                    // Store the first byte\n                    temp <= data_in;\n                    first_byte <= 1'b1;\n                end else begin\n                    // Combine and output 16-bit data\n                    data_out <= {temp, data_in};\n                    valid_out <= 1'b1;\n                    first_byte <= 1'b0;\n                end\n            end\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a ripple 64 bit adder, which is divided into 4 sections to achieve 4-stage pipeline.",
        "ollama_output_code": "module ripple_64bit_adder (\n    input [31:0] a,\n    input [31:0] b,\n    input wire cin,\n    output reg [31:0] sum,\n    output reg cout\n);\n\n// 4-stage pipeline structure\nalways @(posedge clock) begin\n    if (pipeline_stage == 0) begin // Stage 1\n        carry_in[0] <= cin;\n        for (int i = 31; i >= 0; i--) begin\n            full_adder fa(.a(a[i]), .b(b[i]), .cin(carry_in[i + 1]), .sum(s[i]), .cout(carry_in[i]));\n        end\n    end\n    else if (pipeline_stage == 1) begin // Stage 2\n        for (int i = 31; i >= 0; i--) begin\n            full_adder fa(.a(s[i]), .b(carry_in[i]), .cin(0), .sum(temp_sum[i]), .cout(temporary_carry[i]));\n        end\n        carry_in[0] <= temporary_carry[32];\n    end\n    else if (pipeline_stage == 2) begin // Stage 3\n        for (int i = 31; i >= 0; i--) begin\n            full_adder fa(.a(temp_sum[i]), .b(carry_in[i]), .cin(0), .sum(sum[i]), .cout(temporary_carry[i]));\n        end\n    end\n    else if (pipeline_stage == 3) begin // Stage 4\n        for (int i = 31; i >= 0; i--) begin\n            full_adder fa(.a(sum[i]), .b(temporary_carry[i]), .cin(0), .sum(temp_sum[i]), .cout(carry_out));\n        end\n        cout <= carry_out;\n    end\nend\n\n// clock and reset controls pipeline stage\nreg clock_enable, reset;\nreg pipeline_stage = 4'b0001; // initially at Stage 1 (0)\nassign clock = clock_enable & ~reset;\nassign pipeline_clk = !reset | (pipeline_stage == 0) | (clock_enable & (pipeline_stage != 0));\nassign pipeline_enable = (!reset) | (pipeline_stage != 3);\n\n// instantiation of full adder module\nwire [1:0] carry_in;\nreg [31:0] s, temp_sum, temporary_carry;\n\n// Define the full adder module\nmodule full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output reg sum,\n    output reg cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule"
    },
    {
        "input_prompt": "Implement an ALU for 32bit MIPS-ISA CPU.",
        "ollama_output_code": "module alu_32bit_mips (\n    input [31:0] A,       // Operand 1\n    input [31:0] B,       // Operand 2\n    input [4:0] shamt,    // Shift amount (used for shift ops)\n    input [3:0] alu_ctrl, // ALU control signal\n    output reg [31:0] result,\n    output zero           // Zero flag\n);\n\n    assign zero = (result == 32'b0);\n\n    always @(*) begin\n        case (alu_ctrl)\n            4'b0000: result = A & B;                      // AND\n            4'b0001: result = A | B;                      // OR\n            4'b0010: result = A + B;                      // ADD\n            4'b0110: result = A - B;                      // SUB\n            4'b0111: result = ($signed(A) < $signed(B)) ? 32'd1 : 32'd0; // SLT\n            4'b1000: result = (A < B) ? 32'd1 : 32'd0;    // SLTU\n            4'b1100: result = ~(A | B);                   // NOR\n            4'b0011: result = A ^ B;                      // XOR\n            4'b1001: result = B << shamt;                 // SLL\n            4'b1010: result = B >> shamt;                 // SRL\n            4'b1011: result = $signed(B) >>> shamt;       // SRA\n            default: result = 32'd0;\n        endcase\n    end\n\nendmodule"
    }
]