{
    "16multiplier .v": "module shift_add_multiplier_16bit (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] A,\n    input [15:0] B,\n    output reg [31:0] P,\n    output reg done\n);\n\n    reg [15:0] multiplicand;\n    reg [15:0] multiplier;\n    reg [31:0] product;\n    reg [4:0] count; // log2(16) = 4, use 5 bits for safety\n    reg busy;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            P <= 32'd0;\n            product <= 32'd0;\n            multiplicand <= 16'd0;\n            multiplier <= 16'd0;\n            count <= 5'd0;\n            busy <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            if (start && !busy) begin\n                // Initialization on start\n                multiplicand <= A;\n                multiplier <= B;\n                product <= 32'd0;\n                count <= 5'd0;\n                busy <= 1'b1;\n                done <= 1'b0;\n            end else if (busy) begin\n                if (multiplier[0] == 1'b1)\n                    product <= product + {16'd0, multiplicand};\n\n                multiplicand <= multiplicand << 1;\n                multiplier <= multiplier >> 1;\n                count <= count + 1;\n\n                if (count == 15) begin\n                    busy <= 1'b0;\n                    done <= 1'b1;\n                    P <= product + ((multiplier[0]) ? {16'd0, multiplicand} : 32'd0);\n                end\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\nendmodule\n",
    "8multiplier .v": "module pipelined_multiplier_8bit (\n    input clk,\n    input rst,\n    input [7:0] A,\n    input [7:0] B,\n    output reg [15:0] P\n);\n\n    // Stage 1: Register Inputs\n    reg [7:0] A_reg1, B_reg1;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            A_reg1 <= 8'd0;\n            B_reg1 <= 8'd0;\n        end else begin\n            A_reg1 <= A;\n            B_reg1 <= B;\n        end\n    end\n\n    // Stage 2: Generate Partial Products\n    reg [15:0] partial_products [7:0];\n    integer i;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            for (i = 0; i < 8; i = i + 1)\n                partial_products[i] <= 16'd0;\n        end else begin\n            for (i = 0; i < 8; i = i + 1)\n                partial_products[i] <= (B_reg1[i]) ? ({8'd0, A_reg1} << i) : 16'd0;\n        end\n    end\n\n    // Stage 3: Sum partials using tree adder (two levels)\n    reg [15:0] sum1, sum2, sum3, sum4;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum1 <= 16'd0;\n            sum2 <= 16'd0;\n            sum3 <= 16'd0;\n            sum4 <= 16'd0;\n        end else begin\n            sum1 <= partial_products[0] + partial_products[1];\n            sum2 <= partial_products[2] + partial_products[3];\n            sum3 <= partial_products[4] + partial_products[5];\n            sum4 <= partial_products[6] + partial_products[7];\n        end\n    end\n\n    // Stage 4: Final Addition\n    reg [15:0] final_sum;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            final_sum <= 16'd0;\n            P <= 16'd0;\n        end else begin\n            final_sum <= (sum1 + sum2) + (sum3 + sum4);\n            P <= final_sum;\n        end\n    end\n\nendmodule\n",
    "Accumulator32.v": "module MAC_PE (\n    input               clk     ,  \n    input               rst_n   ,  \n    input       [31:0]  a       ,  \n    input       [31:0]  b       ,  \n    output  reg [63:0]  c        \n);\n\n    reg [63:0] acc;  \n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            acc <= 64'd0;\n        end else begin\n            acc <= acc + a * b;\n        end\n    end\n\n    always @(*) begin\n        c = acc;\n    end\n\nendmodule\n",
    "accumulator_4x8bit.v": "module accumulator_4x8bit (\n    input clk,\n    input rst,\n\n    // Input interface\n    input [7:0] data_in,\n    input       valid_in,\n    output reg  ready_out,\n\n    // Output interface\n    output reg [9:0] data_out,  // Max sum = 4 x 255 = 1020\n    output reg       valid_out,\n    input            ready_in\n);\n\n    reg [9:0] sum;      // Accumulator (up to 1020)\n    reg [1:0] count;    // Count of inputs received (0 to 3)\n\n    // Input ready logic\n    always @(*) begin\n        // Accept input when output is not blocking\n        ready_out = (!valid_out) || (valid_out && ready_in);\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum       <= 10'd0;\n            count     <= 2'd0;\n            data_out  <= 10'd0;\n            valid_out <= 1'b0;\n        end else begin\n            // Clear valid_out when downstream has accepted output\n            if (valid_out && ready_in) begin\n                valid_out <= 1'b0;\n            end\n\n            // Accept new input\n            if (valid_in && ready_out) begin\n                sum <= sum + {2'b00, data_in};  // Zero-extend data_in to 10 bits\n                count <= count + 1;\n\n                if (count == 2'd3) begin\n                    data_out <= sum + {2'b00, data_in};  // Final sum\n                    valid_out <= 1'b1;\n                    sum <= 10'd0;\n                    count <= 2'd0;\n                end\n            end\n        end\n    end\n\nendmodule\n",
    "adder_8bit_gate.v": "module full_adder_gate (\n    input a, b, cin,\n    output sum, cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule\n",
    "ALU32.v": "module alu_32bit_mips (\n    input [31:0] A,       // Operand 1\n    input [31:0] B,       // Operand 2\n    input [4:0] shamt,    // Shift amount (used for shift ops)\n    input [3:0] alu_ctrl, // ALU control signal\n    output reg [31:0] result,\n    output zero           // Zero flag\n);\n\n    assign zero = (result == 32'b0);\n\n    always @(*) begin\n        case (alu_ctrl)\n            4'b0000: result = A & B;                      // AND\n            4'b0001: result = A | B;                      // OR\n            4'b0010: result = A + B;                      // ADD\n            4'b0110: result = A - B;                      // SUB\n            4'b0111: result = ($signed(A) < $signed(B)) ? 32'd1 : 32'd0; // SLT\n            4'b1000: result = (A < B) ? 32'd1 : 32'd0;    // SLTU\n            4'b1100: result = ~(A | B);                   // NOR\n            4'b0011: result = A ^ B;                      // XOR\n            4'b1001: result = B << shamt;                 // SLL\n            4'b1010: result = B >> shamt;                 // SRL\n            4'b1011: result = $signed(B) >>> shamt;       // SRA\n            default: result = 32'd0;\n        endcase\n    end\n\nendmodule\n",
    "async_fifo.v": "module async_fifo #(\n    parameter DEPTH = 16,\n    parameter WIDTH = 8\n)(\n    input                   rst,\n\n    // Write interface\n    input                   clk_wr,\n    input       [WIDTH-1:0] data_in,\n    input                   wr_en,\n    output                  full,\n\n    // Read interface\n    input                   clk_rd,\n    output      [WIDTH-1:0] data_out,\n    input                   rd_en,\n    output                  empty\n);\n\n    localparam ADDR_WIDTH = $clog2(DEPTH);\n\n    // FIFO memory\n    reg [WIDTH-1:0] mem [0:DEPTH-1];\n\n    // Write pointer (binary and gray)\n    reg [ADDR_WIDTH:0] wr_ptr_bin = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray_sync1 = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray_sync2 = 0;\n\n    // Read pointer (binary and gray)\n    reg [ADDR_WIDTH:0] rd_ptr_bin = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray_sync1 = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray_sync2 = 0;\n\n    wire [ADDR_WIDTH:0] wr_addr = wr_ptr_bin; // Corrected: use the entire wr_ptr_bin\n    wire [ADDR_WIDTH:0] rd_addr = rd_ptr_bin; // Corrected: use the entire rd_ptr_bin\n\n    // === WRITE DOMAIN ===\n    always @(posedge clk_wr or posedge rst) begin\n        if (rst) begin\n            wr_ptr_bin  <= 0;\n            wr_ptr_gray <= 0;\n        end else if (wr_en && !full) begin\n            mem[wr_ptr_bin[ADDR_WIDTH-1:0]] <= data_in;\n            wr_ptr_bin  <= wr_ptr_bin + 1;\n            wr_ptr_gray <= (wr_ptr_bin + 1) ^ ((wr_ptr_bin + 1) >> 1);  // Binary to Gray\n        end\n    end\n\n    // Synchronize read pointer to write domain\n    always @(posedge clk_wr or posedge rst) begin\n        if (rst) begin\n            rd_ptr_gray_sync1 <= 0;\n            rd_ptr_gray_sync2 <= 0;\n        end else begin\n            rd_ptr_gray_sync1 <= rd_ptr_gray;\n            rd_ptr_gray_sync2 <= rd_ptr_gray_sync1;\n        end\n    end\n\n    // FULL condition\n    assign full = (wr_ptr_gray == {~rd_ptr_gray_sync2[ADDR_WIDTH:ADDR_WIDTH-1], rd_ptr_gray_sync2[ADDR_WIDTH-2:0]});\n\n    // === READ DOMAIN ===\n    always @(posedge clk_rd or posedge rst) begin\n        if (rst) begin\n            rd_ptr_bin  <= 0;\n            rd_ptr_gray <= 0;\n        end else if (rd_en && !empty) begin\n            rd_ptr_bin  <= rd_ptr_bin + 1;\n            rd_ptr_gray <= (rd_ptr_bin + 1) ^ ((rd_ptr_bin + 1) >> 1);  // Binary to Gray\n        end\n    end\n\n    assign data_out = mem[rd_ptr_bin[ADDR_WIDTH-1:0]];\n\n    // Synchronize write pointer to read domain\n    always @(posedge clk_rd or posedge rst) begin\n        if (rst) begin\n            wr_ptr_gray_sync1 <= 0;\n            wr_ptr_gray_sync2 <= 0;\n        end else begin\n            wr_ptr_gray_sync1 <= wr_ptr_gray;\n            wr_ptr_gray_sync2 <= wr_ptr_gray_sync1;\n        end\n    end\n\n    // EMPTY condition\n    assign empty = (rd_ptr_gray == wr_ptr_gray_sync2);\n\nendmodule\n",
    "booth_4_multiplier.v": "module booth_4_multiplier (\n    input [7:0] A,        // 8-bit multiplicand (signed)\n    input [7:0] B,        // 8-bit multiplier (signed)\n    output reg [15:0] P    // 16-bit product\n);\n\n    reg [7:0] M;        // Register for A\n    reg [7:0] Q;        // Register for B\n    reg [7:0] Q_1;      // Q-1, previous least significant bit of Q\n    reg [15:0] A_neg;   // Negative A for subtraction\n    integer i;\n\n    always @* begin\n        // Initialize values\n        M = A;\n        Q = B;\n        Q_1 = 0;\n        P = 0;  // Clear product register\n\n        // Calculate negative of M (Two's complement)\n        A_neg = {8'b0, M} + 1;  // Extend M to 16 bits before negating\n\n        // Booth-4 algorithm loop (8 cycles for 8 bits)\n        for (i = 0; i < 8; i = i + 1) begin\n            case ({Q[0], Q_1} & 9'b000000011)  // Mask to ensure the proper bit-width\n                9'b00000001: P = P + {8'b0, M};    // Add M to product (extend M to 16 bits)\n                9'b00000010: P = P - {8'b0, M};    // Subtract M from product (extend M to 16 bits)\n                default: ;           // Do nothing for 00 or 11\n            endcase\n\n            // Perform the arithmetic shift right (ASR) operation\n            {Q_1, Q} = {P[0], Q[7:1], 1'b0, 7'b0};  // Move Q bits to the right and ensure 16-bit width\n            P = {P[15], P[15:1]};       // Extend the sign bit of P to the left\n        end\n    end\n\nendmodule\n",
    "cla_4bit.v": "module cla_4bit (\n    input  [3:0] a,      // 4-bit input a\n    input  [3:0] b,      // 4-bit input b\n    input        cin,     // Carry-in\n    output [3:0] sum,    // 4-bit sum result\n    output       cout,    // Carry-out\n    output       G,       // Group generate\n    output       P        // Group propagate\n);\n\n    wire [3:0] P_internal, G_internal; // Propagate and Generate signals\n    wire [4:0] c;  // Carry signals, including c[0] (carry-in)\n    \n    // Intermediate signals to break combinational cycles\n    reg [4:0] c_reg;\n\n    // Propagate and Generate logic\n    assign P_internal = a ^ b;  // Propagate: P = A XOR B\n    assign G_internal = a & b;  // Generate: G = A AND B\n\n    // Carry calculation using non-blocking assignments\n    always @(*) begin\n        c_reg[0] = cin;  // First carry is the carry-in\n        c_reg[1] = G_internal[0] | (P_internal[0] & c_reg[0]);\n        c_reg[2] = G_internal[1] | (P_internal[1] & c_reg[1]);\n        c_reg[3] = G_internal[2] | (P_internal[2] & c_reg[2]);\n        c_reg[4] = G_internal[3] | (P_internal[3] & c_reg[3]); // Final carry-out\n    end\n\n    // Assign carry signals from the register\n    assign c = c_reg;\n\n    // Assign the carry-out signal\n    assign cout = c_reg[4];  // Final carry-out\n\n    // Sum calculation\n    assign sum = a ^ b ^ c_reg[3:0];  // Sum is the XOR of inputs and carry\n\n    // Generate and propagate outputs\n    assign G = &G_internal;  // Group generate: AND of all generates\n    assign P = |P_internal;  // Group propagate: OR of all propagates\n\nendmodule\n",
    "controlled_counter.v": "module controlled_counter (\n    input        clk,           // Clock input\n    input        rst,           // Active-high synchronous reset\n    input        valid_count,   // Control signal for counting\n    output reg [3:0] count      // 4-bit counter output\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 4'd0;\n        end else if (valid_count) begin\n            if (count == 4'd12)\n                count <= 4'd0;\n            else\n                count <= count + 1;\n        end\n        // else: hold current count\n    end\n\nendmodule\n",
    "converter_8to16.v": "module width_converter_8to16 (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    input valid_in,\n    output reg [15:0] data_out,\n    output reg valid_out\n);\n\n    reg [7:0] temp;\n    reg has_first_byte;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            temp <= 8'd0;\n            data_out <= 16'd0;\n            has_first_byte <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            valid_out <= 1'b0;  // default, will be set high when output is ready\n\n            if (valid_in) begin\n                if (!has_first_byte) begin\n                    // Store the first byte\n                    temp <= data_in;\n                    has_first_byte <= 1'b1;\n                end else begin\n                    // Combine and output 16-bit data\n                    data_out <= {temp, data_in}; // high byte first\n                    valid_out <= 1'b1;\n                    has_first_byte <= 1'b0;\n                end\n            end\n        end\n    end\nendmodule\n",
    "divisior.v": "module divider_16by8 (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] dividend,\n    input [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [7:0] remainder,\n    output reg done\n);\n\n    reg [4:0] count;\n    reg [15:0] dividend_reg;\n    reg [7:0] divisor_reg;\n    reg [7:0] rem;\n    reg [15:0] quot;\n    reg busy;\n\n    reg [7:0] next_rem;\n    reg [15:0] next_quot;\n    reg [15:0] next_dividend;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            quotient <= 16'd0;\n            remainder <= 8'd0;\n            dividend_reg <= 16'd0;\n            divisor_reg <= 8'd0;\n            rem <= 8'd0;\n            quot <= 16'd0;\n            count <= 5'd0;\n            busy <= 0;\n            done <= 0;\n        end else begin\n            if (start && !busy) begin\n                if (divisor != 0) begin\n                    dividend_reg <= dividend;\n                    divisor_reg <= divisor;\n                    rem <= 8'd0;\n                    quot <= 16'd0;\n                    count <= 5'd16;\n                    busy <= 1;\n                    done <= 0;\n                end else begin\n                    quotient <= 16'd0;\n                    remainder <= dividend[7:0];\n                    done <= 1;\n                end\n            end else if (busy) begin\n                next_rem = {rem[6:0], dividend_reg[15]};\n                next_dividend = {dividend_reg[14:0], 1'b0};\n\n                if (next_rem >= divisor_reg) begin\n                    next_rem = next_rem - divisor_reg;\n                    next_quot = {quot[14:0], 1'b1};\n                end else begin\n                    next_quot = {quot[14:0], 1'b0};\n                end\n\n                rem <= next_rem;\n                quot <= next_quot;\n                dividend_reg <= next_dividend;\n                count <= count - 1;\n\n                if (count == 5'd1) begin\n                    quotient <= next_quot;\n                    remainder <= next_rem;\n                    busy <= 0;\n                    done <= 1;\n                end\n            end else begin\n                done <= 0;\n            end\n        end\n    end\nendmodule\n",
    "edge_detector.v": "module edge_detector (\n    input  wire clk,       // Clock input\n    input  wire rst,       // Active-high reset\n    input  wire a,         // 1-bit slowly changing input signal\n    output reg  rise,      // High for 1 clk on rising edge of a\n    output reg  down       // High for 1 clk on falling edge of a\n);\n\n    reg a_d; // delayed version of 'a'\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            a_d  <= 0;\n            rise <= 0;\n            down <= 0;\n        end else begin\n            // Edge detection\n            rise <= (~a_d) & a;   // rising edge\n            down <= a_d & (~a);  // falling edge\n\n            a_d <= a;            // store previous value of a\n        end\n    end\n\nendmodule\n",
    "freq_divider.v": "module freq_divider (\n    input  wire clk_in,      // 100MHz input clock\n    input  wire rst,         // Active-high synchronous reset\n    output reg  clk_50MHz,   // \u7e692 output (50MHz)\n    output reg  clk_10MHz,   // \u7e6910 output (10MHz)\n    output reg  clk_1MHz     // \u7e69100 output (1MHz)\n);\n\n    // Divide-by-2 counter\n    always @(posedge clk_in) begin\n        if (rst)\n            clk_50MHz <= 0;\n        else\n            clk_50MHz <= ~clk_50MHz;\n    end\n\n    // Divide-by-10 counter (for 10MHz)\n    reg [2:0] cnt_10MHz;\n    always @(posedge clk_in) begin\n        if (rst) begin\n            cnt_10MHz  <= 0;\n            clk_10MHz  <= 0;\n        end else if (cnt_10MHz == 4) begin\n            cnt_10MHz  <= 0;\n            clk_10MHz  <= ~clk_10MHz;\n        end else begin\n            cnt_10MHz <= cnt_10MHz + 1;\n        end\n    end\n\n    // Divide-by-100 counter (for 1MHz)\n    reg [6:0] cnt_1MHz;\n    always @(posedge clk_in) begin\n        if (rst) begin\n            cnt_1MHz  <= 0;\n            clk_1MHz  <= 0;\n        end else if (cnt_1MHz == 49) begin\n            cnt_1MHz  <= 0;\n            clk_1MHz  <= ~clk_1MHz;\n        end else begin\n            cnt_1MHz <= cnt_1MHz + 1;\n        end\n    end\n\nendmodule\n",
    "fsm.v": "module fsm_10011_detector (\n    input  wire clk,     // Clock\n    input  wire rst,     // Active-high synchronous reset\n    input  wire IN,      // Serial input\n    output reg  MATCH    // High for 1 clk when \"10011\" is detected\n);\n\n    // Define FSM states\n    typedef enum logic [2:0] {\n        S0,  // Initial state\n        S1,  // Got '1'\n        S2,  // Got '10'\n        S3,  // Got '100'\n        S4,  // Got '1001'\n        S5   // Got '10011' (final)\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = IN ? S1 : S0;\n            S1: next_state = IN ? S1 : S2;\n            S2: next_state = IN ? S3 : S0;\n            S3: next_state = IN ? S4 : S0;\n            S4: next_state = IN ? S5 : S2;\n            S5: next_state = IN ? S1 : S2;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            MATCH <= 0;\n        else\n            MATCH <= (state == S5);\n    end\n\nendmodule\n",
    "full_adder_16bit.v": "module full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule full_adder_16bit (\n    input  [15:0] a,\n    input  [15:0] b,\n    input         cin,\n    output [15:0] sum,\n    output        cout\n);\n    wire [15:0] carry;\n\n    // First full adder\n    full_adder fa0 (\n        .a(a[0]), .b(b[0]), .cin(cin),\n        .sum(sum[0]), .cout(carry[0])\n    );\n\n    // Remaining 15 full adders\n    genvar i;\n    generate\n        for (i = 1; i < 16; i = i + 1) begin : adder_chain\n            full_adder fa (\n                .a(a[i]), .b(b[i]), .cin(carry[i-1]),\n                .sum(sum[i]), .cout(carry[i])\n            );\n        end\n    endgenerate\n\n    assign cout = carry[15];\n\nendmodule\n",
    "johnson_counter_64.v": "module johnson_counter_64 (\n    input  wire        clk,    // Clock\n    input  wire        rst,    // Active-high synchronous reset\n    output reg [63:0]  q       // 64-bit Johnson counter output\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            q <= 64'b0;  // Reset to all zeros\n        else\n            q <= {~q[63], q[63:1]};  // Shift right and feed inverted MSB to LSB\n    end\n\nendmodule\n",
    "mux_synchronizer.v": "module mux_synchronizer #(\n    parameter WIDTH = 8  // Set the width of the data bus (default 8 bits)\n)(\n    input wire clk,           // Clock signal\n    input wire rst,           // Reset signal\n    input wire [WIDTH-1:0] data_in,  // Data input to be synchronized\n    input wire data_en,      // Enable signal for data synchronization\n    output reg [WIDTH-1:0] data_out  // Synchronized data output\n);\n\n    // Internal signals for synchronization\n    reg [WIDTH-1:0] sync_data_1;  // First stage of synchronization\n    reg [WIDTH-1:0] sync_data_2;  // Second stage of synchronization\n    reg [1:0] data_en_sync;       // Synchronize data_en signal\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sync_data_1 <= 0;\n            sync_data_2 <= 0;\n            data_en_sync <= 0;\n            data_out <= 0;\n        end else begin\n            // Synchronizing the enable signal (data_en) across clock cycles\n            data_en_sync <= {data_en_sync[0], data_en};  // Two flip-flop synchronizer\n\n            // If data_en is stable high (at least 3 cycles), sync data_in\n            if (data_en_sync == 2'b11) begin\n                sync_data_1 <= data_in;  // Store data_in in first stage\n                sync_data_2 <= sync_data_1;  // Transfer to second stage\n            end\n\n            // Output the synchronized data from the second stage\n            data_out <= sync_data_2;\n        end\n    end\n\nendmodule\n",
    "parallel_6.v": "module serial_to_parallel_6bit (\n    input clk,\n    input rst,\n\n    // Input side (valid-ready handshake)\n    input        data_in,\n    input        valid_in,\n    output reg   ready_out,\n\n    // Output side (valid-only handshake)\n    output reg [5:0] data_out,\n    output reg       valid_out\n);\n\n    reg [5:0] data_b;\n    reg [2:0] bit_count;  // Counts from 0 to 6\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_b     <= 6'd0;\n            bit_count  <= 3'd0;\n            valid_out  <= 1'b0;\n            ready_out  <= 1'b1;\n            data_out   <= 6'd0;\n        end else begin\n            valid_out <= 1'b0;  // Default: no valid output\n\n            if (valid_in && ready_out) begin\n                // Shift incoming bit into data_b (LSB first)\n                data_b <= {data_in, data_b[5:1]};\n                bit_count <= bit_count + 1;\n\n                if (bit_count == 3'd5) begin\n                    data_out <= {data_in, data_b[5:1]}; // Final 6-bit vector\n                    valid_out <= 1'b1;\n                    bit_count <= 3'd0;\n                    data_b <= 6'd0;\n                end\n            end\n\n            // Always ready unless currently outputting\n            ready_out <= !(valid_in && bit_count == 3'd5);\n        end\n    end\n\nendmodule\n",
    "parallel_to_serial.v": "module parallel_to_serial (\n    input wire clk,              // Clock signal\n    input wire rst,              // Reset signal\n    input wire [3:0] data_in,   // 4-bit parallel input data\n    input wire valid_in,        // Valid signal for input data\n    output reg serial_out,      // Serial output bit\n    output reg valid_out        // Valid signal for output data\n);\n\n    reg [3:0] data_buffer;      // To hold the input data\n    reg [2:0] count;            // 3-bit counter for shifting out the bits\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_buffer <= 4'b0;\n            count <= 3'b0;\n            serial_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else if (valid_in) begin\n            if (count == 3'b0) begin\n                // On the first cycle, load the input data into the buffer\n                data_buffer <= data_in;\n                valid_out <= 1'b1;\n            end else begin\n                // Shift the data out serially\n                serial_out <= data_buffer[3];  // Take the MSB for output\n                data_buffer <= {data_buffer[2:0], 1'b0}; // Shift the data left\n            end\n\n            // Increment counter to keep track of the shifts\n            count <= count + 1;\n\n            // When all 4 bits have been sent, reset counter and valid_out\n            if (count == 3'b011) begin\n                count <= 3'b0;\n                valid_out <= 1'b0;\n            end\n        end else begin\n            // If valid_in is low, do not output valid data\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule\n",
    "perpetual_calendar.v": "module perpetual_calendar (\n    input clk,          // Clock input (assumed 1 Hz for 1-second tick)\n    input rst,          // Asynchronous reset\n    output reg [5:0] Secs,  // 0 - 59\n    output reg [5:0] Mins,  // 0 - 59\n    output reg [4:0] Hours  // 0 - 23\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            Secs  <= 0;\n            Mins  <= 0;\n            Hours <= 0;\n        end else begin\n            if (Secs == 59) begin\n                Secs <= 0;\n\n                if (Mins == 59) begin\n                    Mins <= 0;\n\n                    if (Hours == 23)\n                        Hours <= 0;\n                    else\n                        Hours <= Hours + 1;\n                end else begin\n                    Mins <= Mins + 1;\n                end\n            end else begin\n                Secs <= Secs + 1;\n            end\n        end\n    end\n\nendmodule\n",
    "pipeline_multiplier_4bit.v": "module pipeline_multiplier_4bit (\n    input  wire [3:0] A,        // 4-bit input A\n    input  wire [3:0] B,        // 4-bit input B\n    input  wire clk,             // Clock signal\n    input  wire rst,             // Reset signal\n    output reg [7:0] P          // 8-bit output product\n);\n\n    // Intermediate signals for pipelining\n    reg [7:0] partial_0, partial_1, partial_2, partial_3;\n    reg [7:0] sum_0, sum_1, sum_2;\n\n    // Stage 1: Generate partial products for each bit of B and A\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_0 <= 0;\n        end else begin\n            partial_0 <= {4'b0, A} & {8{B[0]}};  // Partial product for bit 0 of B\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_1 <= 0;\n        end else begin\n            partial_1 <= {3'b0, A, 1'b0} & {8{B[1]}};  // Partial product for bit 1 of B (shifted by 1)\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_2 <= 0;\n        end else begin\n            partial_2 <= {2'b0, A, 2'b0} & {8{B[2]}};  // Partial product for bit 2 of B (shifted by 2)\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            partial_3 <= 0;\n        end else begin\n            partial_3 <= {1'b0, A, 3'b0} & {8{B[3]}};  // Partial product for bit 3 of B (shifted by 3)\n        end\n    end\n\n    // Stage 2: Add partial products to get sum_0\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum_0 <= 0;\n        end else begin\n            sum_0 <= partial_0 + partial_1;  // Add first two partial products\n        end\n    end\n\n    // Stage 3: Add the next partial product to sum_0 to get sum_1\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum_1 <= 0;\n        end else begin\n            sum_1 <= sum_0 + partial_2;  // Add partial product 2\n        end\n    end\n\n    // Stage 4: Add the final partial product to sum_1 to get sum_2\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum_2 <= 0;\n        end else begin\n            sum_2 <= sum_1 + partial_3;  // Add partial product 3\n        end\n    end\n\n    // Output product: Assign the final sum to the output product P\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            P <= 0;\n        end else begin\n            P <= sum_2;  // Assign final sum as output product\n        end\n    end\n\nendmodule\n",
    "pulse_synchronizer.v": "module pulse_synchronizer (\n    input wire clk_a,            // Fast clock A\n    input wire clk_b,            // Slow clock B\n    input wire rst,              // Reset signal\n    input wire data_in,          // Single clock-width pulse in the A domain\n    output reg data_out          // Single clock-width pulse in the B domain\n);\n\n    // Synchronizer flip-flops\n    reg sync_1, sync_2;          // Synchronize the data_in signal from clk_a to clk_b\n\n    always @(posedge clk_a or posedge rst) begin\n        if (rst) begin\n            sync_1 <= 1'b0;\n            sync_2 <= 1'b0;\n        end else begin\n            sync_1 <= data_in;  // First stage synchronizer\n            sync_2 <= sync_1;    // Second stage synchronizer\n        end\n    end\n\n    // Generate pulse in the B domain\n    always @(posedge clk_b or posedge rst) begin\n        if (rst) begin\n            data_out <= 1'b0;\n        end else begin\n            // Detect rising edge in the B domain and generate a pulse\n            if (sync_2 && !sync_1) begin\n                data_out <= 1'b1;  // Generate pulse\n            end else begin\n                data_out <= 1'b0;  // Clear pulse after one clock cycle\n            end\n        end\n    end\n\nendmodule\n",
    "right_shifter.v": "module right_shifter (\n    input clk,\n    input d,\n    output reg [7:0] q\n);\n\n    // Initialize q to 0 at simulation start\n    initial begin\n        q = 8'd0;\n    end\n\n    always @(posedge clk) begin\n        q <= (q >> 1);  // Right shift\n        q[7] <= d;      // Insert new bit at MSB\n    end\n\nendmodule\n",
    "ripple64.v": "module pipelined_ripple_adder_64bit (\n    input clk,\n    input rst,\n    input [63:0] A,\n    input [63:0] B,\n    output reg [63:0] Sum,\n    output reg done\n);\n\n    // Stage 1 registers\n    reg [15:0] A_s1, B_s1;\n    reg [15:0] sum_s1;\n    reg carry_s1;\n\n    // Stage 2 registers\n    reg [15:0] A_s2, B_s2;\n    reg [15:0] sum_s2;\n    reg carry_s2;\n    \n    // Stage 3 registers\n    reg [15:0] A_s3, B_s3;\n    reg [15:0] sum_s3;\n    reg carry_s3;\n\n    // Stage 4 registers\n    reg [15:0] A_s4, B_s4;\n    reg [15:0] sum_s4;\n    reg carry_s4;\n    \n    // Final carry and sum pipeline\n    reg [15:0] s1_final, s2_final, s3_final, s4_final;\n    reg [3:0] valid;\n\n    // Carry lookahead\n    function [16:0] ripple_add_16;\n        input [15:0] x, y;\n        input c_in;\n        reg [16:0] result;\n        begin\n            result = x + y + {15'b0, c_in}; // Extend c_in to 16 bits\n            ripple_add_16 = result;\n        end\n    endfunction\n\n    always @(posedge clk or posedge rst) begin\n        reg [16:0] result_s1, result_s2, result_s3, result_s4; // Declare result variables here\n        if (rst) begin\n            // Resetting all variables with non-blocking assignments\n            {sum_s1, carry_s1, sum_s2, carry_s2, sum_s3, carry_s3, sum_s4, carry_s4} <= 0;\n            {s1_final, s2_final, s3_final, s4_final} <= 0;\n            valid <= 0;\n            Sum <= 0;\n            done <= 0;\n        end else begin\n            // Stage 1: bits [15:0]\n            result_s1 <= ripple_add_16(A[15:0], B[15:0], 1'b0);\n            sum_s1 <= result_s1[15:0];\n            carry_s1 <= result_s1[16];\n\n            A_s2 <= A[31:16]; B_s2 <= B[31:16];\n\n            // Stage 2: bits [31:16]\n            result_s2 <= ripple_add_16(A_s2, B_s2, carry_s1);\n            sum_s2 <= result_s2[15:0];\n            carry_s2 <= result_s2[16];\n\n            A_s3 <= A[47:32]; B_s3 <= B[47:32];\n\n            // Stage 3: bits [47:32]\n            result_s3 <= ripple_add_16(A_s3, B_s3, carry_s2);\n            sum_s3 <= result_s3[15:0];\n            carry_s3 <= result_s3[16];\n\n            A_s4 <= A[63:48]; B_s4 <= B[63:48];\n\n            // Stage 4: bits [63:48]\n            result_s4 <= ripple_add_16(A_s4, B_s4, carry_s3);\n            sum_s4 <= result_s4[15:0];\n            carry_s4 <= result_s4[16];\n\n            // Output sum\n            s1_final <= sum_s1;\n            s2_final <= sum_s2;\n            s3_final <= sum_s3;\n            s4_final <= sum_s4;\n\n            Sum <= {s4_final, s3_final, s2_final, s1_final};\n\n            // Track when output is valid\n            valid <= {valid[2:0], 1'b1};\n            done <= valid[3];\n        end\n    end\nendmodule\n",
    "signal_generator.v": "module signal_generator (\n    input clk,\n    input rst,\n    input [1:0] wave_choice,        // 0: Square, 1: Sawtooth, 2: Triangle\n    output reg [7:0] signal_out\n);\n\n    reg [7:0] counter;\n    reg direction;  // Used for triangle wave: 0 = up, 1 = down\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 8'd0;\n            signal_out <= 8'd0;\n            direction <= 1'b0;\n        end else begin\n            case (wave_choice)\n                2'b00: begin\n                    // Square wave: toggle every 128 steps\n                    counter <= counter + 1;\n                    signal_out <= (counter < 128) ? 8'd255 : 8'd0;\n                end\n\n                2'b01: begin\n                    // Sawtooth wave: ramp up continuously\n                    counter <= counter + 1;\n                    signal_out <= counter;\n                end\n\n                2'b10: begin\n                    // Triangle wave: ramp up and down\n                    if (!direction) begin\n                        counter <= counter + 1;\n                        if (counter == 8'd255) direction <= 1;\n                    end else begin\n                        counter <= counter - 1;\n                        if (counter == 8'd0) direction <= 0;\n                    end\n                    signal_out <= counter;\n                end\n\n                default: signal_out <= 8'd0;\n            endcase\n        end\n    end\n\nendmodule\n",
    "traffic_light.v": "module traffic_light_controller (\n    input clk,\n    input rst,\n    input pedestrian_button,\n    output reg red,\n    output reg yellow,\n    output reg green\n);\n\n    // State Encoding\n    localparam GREEN  = 2'b00;\n    localparam YELLOW = 2'b01;\n    localparam RED    = 2'b10;\n    localparam INVALID = 2'b11; // Add an invalid state for safety\n\n    reg [1:0] state, next_state;\n    reg [6:0] counter;  // Enough to count up to 60\n    reg shorten_green;  // Indicates green should be shortened\n    reg [6:0] green_time;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= GREEN;\n            counter <= 0;\n            shorten_green <= 0;\n            green_time <= 60;\n        end else begin\n            state <= next_state;\n\n            // Detect pedestrian button press during green\n            if (state == GREEN && pedestrian_button && counter < 51) begin\n                shorten_green <= 1;\n                green_time <= 10;\n            end else if (state == GREEN && !pedestrian_button) begin\n                shorten_green <= 0;\n                green_time <= 60;\n            end\n\n            // Counter logic\n            if (state != next_state) begin\n                counter <= 0; // Reset the counter on state change\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    // State transition logic\n    always @(*) begin\n        next_state = state;\n\n        case (state)\n            GREEN: begin\n                if ((shorten_green && counter >= 10) || (!shorten_green && counter >= 60))\n                    next_state = YELLOW;\n            end\n            YELLOW: begin\n                if (counter >= 5)\n                    next_state = RED;\n            end\n            RED: begin\n                if (counter >= 10)\n                    next_state = GREEN;\n            end\n            default: next_state = INVALID; // Handle the invalid state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            GREEN: begin\n                green  = 1;\n                yellow = 0;\n                red    = 0;\n            end\n            YELLOW: begin\n                green  = 0;\n                yellow = 1;\n                red    = 0;\n            end\n            RED: begin\n                green  = 0;\n                yellow = 0;\n                red    = 1;\n            end\n            default: begin // Add default case for undefined state\n                green  = 0;\n                yellow = 0;\n                red    = 0;\n            end\n        endcase\n    end\n\nendmodule\n",
    "true_dual_port_ram.v": "module true_dual_port_ram (\n    input wire clk,             // Clock signal\n    input wire rst,             // Reset signal\n    input wire read_en,         // Read enable signal\n    input wire [2:0] read_addr, // 3-bit address for reading (depth 8)\n    output reg [3:0] read_data, // 4-bit data read from memory\n    input wire write_en,        // Write enable signal\n    input wire [2:0] write_addr,// 3-bit address for writing (depth 8)\n    input wire [3:0] write_data // 4-bit data to be written to memory\n);\n\n    // 8x4-bit memory array initialized to zero (4-bit wide, 8-deep)\n    reg [3:0] mem [7:0];\n\n    // Synchronous reset to initialize memory to 0\n    integer i;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Initialize all memory locations to 0000\n            for (i = 0; i < 8; i = i + 1) begin\n                mem[i] <= 4'b0000;\n            end\n        end else begin\n            // Perform write operation when write_en is high\n            if (write_en) begin\n                mem[write_addr] <= write_data;\n            end\n        end\n    end\n\n    // Asynchronous read operation\n    always @(*) begin\n        if (read_en) begin\n            read_data = mem[read_addr];  // Output the data at the specified read address\n        end else begin\n            read_data = 4'b0000;         // If read_en is not enabled, output 0000\n        end\n    end\n\nendmodule\n"
}