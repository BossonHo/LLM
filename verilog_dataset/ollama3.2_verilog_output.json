[
    {
        "input_prompt": "Implement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of a multiplied by b will be accumulated in this register, and the c shows the value of the register.",
        "ollama_output_code": "module MAC_PE (\n    input               clk     ,  \n    input               rst_n   ,  \n    input       [31:0]  a       ,  \n    input       [31:0]  b       ,  \n    output  reg [63:0]  c        \n);\n\nreg [63:0] acc;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        acc <= 64'd0;\n    end else begin\n        acc <= acc + a * b;\n    end\nend\n\nalways @(*) begin\n    c = acc;\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement the design of unsigned 8bit multiplier based on pipelining processing.",
        "ollama_output_code": "module pipelined_multiplier_8bit(\n    input clk,\n    input rst,\n    input [7:0] A,\n    input [7:0] B,\n    output reg [15:0] P\n);\n\nreg [7:0] A_reg1, B_reg1;\nreg [15:0] partial_products [7:0];\nreg [15:0] sum1, sum2, sum3, sum4;\nreg [15:0] final_sum;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        A_reg1 <= 8'd0,\n                B_reg1 <= 8'd0,\n                partial_products[0] <= 16'd0,\n                partial_products[1] <= 16'd0,\n                partial_products[2] <= 16'd0,\n                partial_products[3] <= 16'd0,\n                partial_products[4] <= 16'd0,\n                partial_products[5] <= 16'd0,\n                partial_products[6] <= 16'd0,\n                partial_products[7] <= 16'd0,\n                sum1 <= 16'd0,\n                sum2 <= 16'd0,\n                sum3 <= 16'd0,\n                sum4 <= 16'd0,\n                final_sum <= 16'd0,\n                P <= 16'd0;\n    else\n        A_reg1 <= A[7:0],\n                 B_reg1 <= B[7:0],\n                 partial_products[0] <= (B_reg1[7]) ? ({8'd0, A_reg1} << 7) : 16'd0,\n                 partial_products[1] <= (B_reg1[6]) ? ({8'd0, A_reg1} << 6) : 16'd0,\n                 partial_products[2] <= (B_reg1[5]) ? ({8'd0, A_reg1} << 5) : 16'd0,\n                 partial_products[3] <= (B_reg1[4]) ? ({8'd0, A_reg1} << 4) : 16'd0,\n                 partial_products[4] <= (B_reg1[3]) ? ({8'd0, A_reg1} << 3) : 16'd0,\n                 partial_products[5] <= (B_reg1[2]) ? ({8'd0, A_reg1} << 2) : 16'd0,\n                 partial_products[6] <= (B_reg1[1]) ? ({8'd0, A_reg1} << 1) : 16'd0,\n                 partial_products[7] <= (B_reg1[0]) ? ({8'd0, A_reg1}) : 16'd0,\n\n            sum1 <= partial_products[0] + partial_products[1],\n            sum2 <= partial_products[2] + partial_products[3],\n            sum3 <= partial_products[4] + partial_products[5],\n            sum4 <= partial_products[6] + partial_products[7],\n\n            final_sum <= (sum1 + sum2) + (sum3 + sum4),\n            P <= final_sum;\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement the design of unsigned 16bit multiplier based on shifting and adding opration..",
        "ollama_output_code": "module shift_add_multiplier_16bit (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] A,\n    input [15:0] B,\n    output reg [31:0] P,\n    output reg done\n);\n\nreg [15:0] multiplicand;\nreg [15:0] multiplier;\nreg [31:0] product;\nreg [4:0] count; // log2(16) = 4, use 5 bits for safety\nreg busy;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        P <= 32'd0;\n        product <= 32'd0;\n        multiplicand <= 16'd0;\n        multiplier <= 16'd0;\n        count <= 5'd0;\n        busy <= 1'b0;\n        done <= 1'b0;\n    end else begin\n        if (start && !busy) begin\n            multiplicand <= A;\n            multiplier <= B;\n            product <= 32'd0;\n            count <= 5'd0;\n            busy <= 1'b1;\n            done <= 1'b0;\n        end else if (busy) begin\n            if (multiplier[0] == 1'b1)\n                product <= product + {16'd0, multiplicand};\n\n            multiplicand <= multiplicand << 1;\n            multiplier <= multiplier >> 1;\n            count <= count + 1;\n\n            if (count == 15) begin\n                busy <= 1'b0;\n                done <= 1'b1;\n                P <= product + ((multiplier[0]) ? {16'd0, multiplicand} : 32'd0);\n            end\n        end else begin\n            done <= 1'b0;\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a 16-bit divider module, dividend is 16-bit and divider is 8-bit. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.",
        "ollama_output_code": "module divider_16by8 (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] dividend,\n    input [7:0] divisor,\n    output reg [15:0] quotient,\n    output reg [7:0] remainder,\n    output reg done\n);\n\nreg [4:0] count;\nreg [15:0] dividend_reg;\nreg [7:0] divisor_reg;\nreg [7:0] rem;\nreg [15:0] quot;\nreg busy;\n\nreg [7:0] next_rem;\nreg [15:0] next_quot;\nreg [15:0] next_dividend;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        quotient <= 16'd0;\n        remainder <= 8'd0;\n        dividend_reg <= 16'd0;\n        divisor_reg <= 8'd0;\n        rem <= 8'd0;\n        quot <= 16'd0;\n        count <= 5'd0;\n        busy <= 0;\n        done <= 0;\n    end else begin\n        if (start && !busy) begin\n            if (divisor != 0) begin\n                dividend_reg <= dividend;\n                divisor_reg <= divisor;\n                rem <= 8'd0;\n                quot <= 16'd0;\n                count <= 5'd16;\n                busy <= 1;\n                done <= 0;\n            end else begin\n                quotient <= 16'd0;\n                remainder <= dividend[7:0];\n                done <= 1;\n            end\n        end else if (busy) begin\n            next_rem = {rem[6:0], dividend_reg[15]};\n            next_dividend = {dividend_reg[14:0], 1'b0};\n\n            if (next_rem >= divisor_reg) begin\n                next_rem = next_rem - divisor_reg;\n                quot <= {quot[14:0], 1'b1};\n            end else begin\n                quot <= quot[14:0];\n            end\n\n            rem <= next_rem;\n            dividend_reg <= next_dividend;\n            count <= count - 1;\n\n            if (count == 5'd1) begin\n                quotient <= quot;\n                remainder <= next_rem;\n                busy <= 0;\n                done <= 1;\n            end\n        end else begin\n            done <= 0;\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a module to achieve serial input data accumulation output, input input 8bit data, whenever the module receives 4 input data, the output outputs 4 received data accumulation results. The input and output interfaces interact with the upstream and downstream using the valid-ready two-way handshake mechanism. When both upstream and downstream are required to be able to transmit at full speed, there is no bubble in data transmission, and no additional performance loss can be caused due to the design of this module.",
        "ollama_output_code": "module accumulator_4x8bit (\n    input clk,\n    input rst,\n\n    // Input interface\n    input [7:0] data_in[3],\n    input       valid_in[3],\n    output reg  ready_out[3],\n    output reg [9:0] data_out,  // Max sum = 4 x 255 = 1020\n    output reg       valid_out,\n    input            ready_in\n);\n\nreg [9:0] sum;      // Accumulator (up to 1020)\nreg [1:0] count;    // Count of inputs received (0 to 3)\n\nalways @(*) begin\n    ready_out[0] = (!valid_in[0]) || (valid_in[0] && ready_in);\n    ready_out[1] = (!valid_in[1]) || (valid_in[1] && ready_out[0]);\n    ready_out[2] = (!valid_in[2]) || (valid_in[2] && ready_out[1]);\n    ready_out[3] = (!valid_in[3]) || (valid_in[3] && ready_out[2]);\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        sum       <= 10'd0;\n        count     <= 2'd0;\n        data_out  <= 10'd0;\n        valid_out <= 1'b0;\n    end else begin\n        // Clear valid_out when downstream has accepted output\n        if (valid_out && ready_in[3]) begin\n            valid_out <= 1'b0;\n        end\n\n        // Accept new input\n        for (int i = 3; i >= 0; i--) begin\n            if (valid_in[i] && ready_out[i]) begin\n                sum <= sum + {2'b00, data_in[i]};  // Zero-extend data_in to 10 bits\n                count <= count + 1;\n\n                if (count == 3) begin\n                    data_out <= sum + {2'b00, data_in[0]} + {2'b00, data_in[1]} + {2'b00, data_in[2]};\n                    valid_out <= 1'b1;\n                    sum <= 10'd0;\n                    count <= 2'd0;\n                end\n            end\n        end\n    end\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement a module of an 8 bit adder in gate level.",
        "ollama_output_code": "module full_adder_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input  cin,\n    output [7:0] sum,\n    output [1:0] cout\n);\n\n    assign sum = {a[3:0], a[7:4]};\n    assign {cout[1], cout[0]} = (a[7] + b[7] + cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input  cin,\n    output [15:0] sum,\n    output [2:0] cout\n);\n\n    wire [7:0] w1;\n    wire [7:0] w2;\n    wire [8:0] w3;\n\n    assign w1 = a[7:4];\n    assign w2 = b[7:4];\n\n    full_adder_8bit fa(\n        .a(w1),\n        .b(w2),\n        .cin(cin),\n        .sum(w3[7:4]),\n        .cout(cout)\n    );\n\n    wire [8:0] w4;\n\n    assign w4 = a[3:0];\n    assign w5 = b[3:0];\n\n    full_adder_8bit fb(\n        .a(w4),\n        .b(w5),\n        .cin(cin),\n        .sum(w6[7:4]),\n        .cout(cout)\n    );\n\n    wire [8:0] w6;\n\n    assign w6 = {w3[3:0], w4};\n\n    full_adder_8bit f(\n        .a(w6),\n        .b(a[3:0]),\n        .cin(cin),\n        .sum(sum),\n        .cout(cout)\n    );\n\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a 16-bit full adder.",
        "ollama_output_code": "module full_adder_16bit (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  cin,\n    output [15:0] sum,\n    output cout\n);\n    assign {cout, sum[15], sum[14:2], sum[1]} = {{a[15], b[15]}, {a[14]+b[14], a[13]+b[13]+cin[13]},\n                                              {a[12]+b[12], a[11]+b[11]+cin[11]}, \n                                              {a[10]+b[10], a[9]+b[9]+cin[9]}};\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a carry lookahead 32 bit adder based on CLAs.",
        "ollama_output_code": "module clas_32_bit_adder (\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] sum,\n    output [1:0] cout\n);\n\n    assign sum = a + b;\n    for (int i = 31; i >= 2; i--) begin : clas_loop_1\n        assign sum[i-1] = sum[i-1] ^ (a[i] & b[i]);\n        assign cout[1] = a[i] & b[i];\n        if (cout[0]) cout[0] <= cout[1];\n    end : cls_loop_1\n\n    for (int i = 30; i >= 2; i--) begin : cls_loop_2\n        assign sum[i-1] = sum[i-1] ^ ((a[i-1] & b[i-1]) | (a[i] & b[i]));\n    end : cls_loop_2\n\nendmodule"
    },
    {
        "input_prompt": "Implement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16,parameter WIDTH = 8). ",
        "ollama_output_code": "module async_fifo #(\n    parameter DEPTH = 16,\n    parameter WIDTH = 8\n)(\n    input                   rst,\n\n    // Write interface\n    input                   clk_wr,\n    input       [WIDTH-1:0] data_in,\n    input                   wr_en,\n    output                  full,\n\n    // Read interface\n    input                   clk_rd,\n    output      [WIDTH-1:0] data_out,\n    input                   rd_en,\n    output                  empty\n);\n\n    localparam ADDR_WIDTH = $clog2(DEPTH);\n\n    // FIFO memory\n    reg [WIDTH-1:0] mem [0:DEPTH-16];\n\n    // Write pointer (binary and gray)\n    reg [ADDR_WIDTH:0] wr_ptr_bin = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray_sync1 = 0;\n    reg [ADDR_WIDTH:0] wr_ptr_gray_sync2 = 0;\n\n    // Read pointer (binary and gray)\n    reg [ADDR_WIDTH:0] rd_ptr_bin = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray_sync1 = 0;\n    reg [ADDR_WIDTH:0] rd_ptr_gray_sync2 = 0;\n\n    wire [ADDR_WIDTH:0] wr_addr = wr_ptr_bin;\n    wire [ADDR_WIDTH:0] rd_addr = rd_ptr_bin;\n\n    // === WRITE DOMAIN ===\n    always @(posedge clk_wr or posedge rst) begin\n        if (rst) begin\n            wr_ptr_bin  <= 0;\n            wr_ptr_gray <= 0;\n        end else if (wr_en && !full) begin\n            mem[wr_addr] <= data_in;\n            wr_ptr_bin  <= wr_ptr_bin + 1;\n            wr_ptr_gray <= (wr_ptr_bin + 1) ^ ((wr_ptr_bin + 1) >> 1);\n        end\n    end\n\n    // Synchronize read pointer to write domain\n    always @(posedge clk_wr or posedge rst) begin\n        if (rst) begin\n            rd_ptr_gray_sync1 <= 0;\n            rd_ptr_gray_sync2 <= 0;\n        end else begin\n            rd_ptr_gray_sync1 <= rd_ptr_gray;\n            rd_ptr_gray_sync2 <= rd_ptr_gray_sync1;\n        end\n    end\n\n    // FULL condition\n    assign full = (wr_ptr_gray == {~rd_ptr_gray_sync2[ADDR_WIDTH:ADDR_WIDTH-1], rd_ptr_gray_sync2[ADDR_WIDTH-2:0]});\n\n    // === READ DOMAIN ===\n    always @(posedge clk_rd or posedge rst) begin\n        if (rst) begin\n            rd_ptr_bin  <= 0;\n            rd_ptr_gray <= 0;\n        end else if (rd_en && !empty) begin\n            rd_ptr_bin  <= rd_ptr_bin + 1;\n            rd_ptr_gray <= (rd_ptr_bin + 1) ^ ((rd_ptr_bin + 1) >> 1);\n        end\n    end\n\n    assign data_out = mem[rd_addr];\n\n    // Synchronize write pointer to read domain\n    always @(posedge clk_rd or posedge rst) begin\n        if (rst) begin\n            wr_ptr_gray_sync1 <= 0;\n            wr_ptr_gray_sync2 <= 0;\n        end else begin\n            wr_ptr_gray_sync1 <= wr_ptr_gray;\n            wr_ptr_gray_sync2 <= wr_ptr_gray_sync1;\n        end\n    end\n\n    // EMPTY condition\n    assign empty = (rd_ptr_gray == wr_ptr_gray_sync2);\nendmodule"
    },
    {
        "input_prompt": "Implement a module of perpetual calendar. The output port Secs counts from 0 to 59, and when the Secs count reaches 59, the output port Mins increases by one and stops counting until minute=59. When the Mins count reaches 59, the output port Hours increases by one and stops counting until Hours=24.",
        "ollama_output_code": "module perpetual_calendar (\n    input clk,          // Clock input (assumed 1 Hz for 1-second tick)\n    input rst,          // Asynchronous reset\n    output reg [5:0] Secs,  // 0 - 59\n    output reg [5:0] Mins,  // 0 - 59\n    output reg [4:0] Hours  // 0 - 23\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            Secs  <= 0;\n            Mins  <= 0;\n            Hours <= 0;\n        end else begin\n            if (Secs == 59) begin\n                Mins  <= 0;\n\n                if (Mins == 59) begin\n                    Hours <= 0;\n\n                    if (Hours == 23)\n                        Hours <= 0;\n                    else\n                        Hours <= Hours + 1;\n                end else begin\n                    Mins <= Mins + 1;\n                end\n            end else begin\n                Secs <= Secs + 1;\n            end\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a counter design that requires counting from 4 'b0000 to 4' d12. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is invalid.",
        "ollama_output_code": "module counter (\n    input        clk,           // Clock input\n    input        rst,           // Active-high synchronous reset\n    input        valid_count,   // Control signal for counting\n    output reg [3:0] count      // 4-bit counter output\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 4'd0;\n    end else if (!valid_count) begin\n        count <= count;\n    end else if (count == 4'd12)\n        count <= 4'd0;\n    else\n        count <= count + 1;\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement a module for edge detection, there is a slowly changing 1 bit signal a. When the rising edge of signal a is detected, the indicating signal rise is given; when the falling edge of signal A is shown, the indicating signal down is given. rise and down are high on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.",
        "ollama_output_code": "module edge_detector (\n    input  wire clk,       // Clock input\n    input  wire rst,       // Active-high reset\n    input  wire a,         // 1-bit slowly changing input signal\n    output reg  rise,      // High for 1 clk on rising edge of a\n    output reg  down       // High for 1 clk on falling edge of a\n);\n\nreg a_d; // delayed version of 'a';\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        a_d  <= 0;\n        rise <= 0;\n        down <= 0;\n    end else begin\n        rise <= (~a_d & a | (~a_d & ~a));   // rising edge\n        down <= (a_d & a) | (a_d & ~a);  // falling edge\n\n        a_d <= a;            // store previous value of a\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.",
        "ollama_output_code": "module freq_divider (\n    input  wire clk_in,      // 100MHz input clock\n    input  wire rst,         // Active-high synchronous reset\n    output reg  clk_50MHz,   // 繩2 output (50MHz)\n    output reg  clk_10MHz,   // 繩10 output (10MHz)\n    output reg  clk_1MHz     // 繩100 output (1MHz)\n);\n\n    always @(posedge clk_in) begin\n        if (rst)\n            clk_50MHz <= 0;\n        else\n            clk_50MHz <= ~clk_50MHz;\n    end\n\n    assign clk_10MHz = ~clk_50MHz;\n\n    reg [5:0] cnt_1MHz;\n    always @(posedge clk_in) begin\n        if (rst)\n            cnt_1MHz  <= 0;\n        else if (cnt_1MHz == 48) begin\n            cnt_1MHz  <= 0;\n            clk_1MHz  <= ~clk_1MHz;\n        end else begin\n            cnt_1MHz <= cnt_1MHz + 1;\n        end\n    end\n\n    assign clk_1MHz = ~cnt_1MHz;\n\nendmodule"
    },
    {
        "input_prompt": "Implement a FSM detection circuit that detects a single bit input IN. When the input is 10011, output MATCH is high, and MATCH is 0 in other cases.",
        "ollama_output_code": "module fsm_10011_detector (\n    input  wire clk,     // Clock\n    input  wire rst,     // Active-high synchronous reset\n    input  wire IN,      // Serial input\n    output reg  MATCH    // High for 1 clk when \"10011\" is detected\n);\n\ntypedef enum logic [2:0] {\n    S0,  // Initial state\n    S1,  // Got '1'\n    S2,  // Got '10'\n    S3,  // Got '100'\n    S4,  // Got '1001'\n    S5   // Got '10011' (final)\n} state_t;\n\nstate_t state, next_state;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        state <= S0;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        S0: next_state = IN ? S1 : S0;\n        S1: next_state = IN ? S1 : S2;\n        S2: next_state = IN ? S3 : S0;\n        S3: next_state = IN ? S4 : S0;\n        S4: next_state = IN ? S5 : S2;\n        S5: next_state = IN ? S1 : S0;\n    endcase\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        MATCH <= 0;\n    else\n        MATCH <= (state == S5);\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement a 64-bit Johnson counter (torsional ring counter), and cyclic state of the the similar 4-bit Johnson counter is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.",
        "ollama_output_code": "module johnson_counter_64 (\n    input  wire        clk,    // Clock\n    input  wire        rst,    // Active-high synchronous reset\n    output reg [63:0]  q       // 64-bit Johnson counter output\n);\n\n    reg [7:0]    state; // 4-bit state\n    reg [47:40]  count; // 8-bit counter\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= 8'b0000;\n        else\n            state <= {state[6:], state[5:0]};\n        \n        if (count == 8'hfff) \n            count <= 8'b0000;\n        else \n            count <= {count[7:], count[0:1]};\n            \n        q <= {state, count};\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement an 8bit booth-4 multiplier. ",
        "ollama_output_code": "module booth_4_multiplier (\n    input [7:0] A,        // 8-bit multiplicand (signed)\n    input [7:0] B,        // 8-bit multiplier (signed)\n    output reg [15:0] P    // 16-bit product\n);\n\nreg [7:0] M;            // Register for A\nreg [7:0] Q;            // Register for B\nreg [7:0] Q_1;          // Q-1, previous least significant bit of Q\nreg [15:0] A_neg;       // Negative A for subtraction\ninteger i;\n\nalways @* begin\n    M = A;\n    Q = B;\n    Q_1 = 0;\n    P[15:0] = 16'd0;      // Clear product register\n\n    A_neg = {8'b0, ~M + 1}; // Two's complement for negative A\n\n    for (i = 0; i < 8; i = i + 1) begin\n        case ({Q[0], Q_1} & 9'b000000011)\n            9'b00000001: P[15:0] = P[15:0] + {8'b0, M}; // Add M to product (extend M to 16 bits)\n            9'b00000010: P[15:0] = P[15:0] - {8'b0, M}; // Subtract M from product (extend M to 16 bits)\n            default:\n                break;\n        endcase\n\n        Q_1 = Q & ({1'b1, ~Q}); // Arithmetic right shift\n        Q = {Q[7], Q};\n        P[15:0] = (P[15:0] << 1) | Q_1;\n    end\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement the design of 4bit unsigned number pipeline multiplier.",
        "ollama_output_code": "module pipeline_multiplier_4bit (\n    input  wire [3:0] A,        // 4-bit input A\n    input  wire [3:0] B,        // 4-bit input B\n    input  wire clk,             // Clock signal\n    input  wire rst,             // Reset signal\n    output reg [7:0] P          // 8-bit output product\n);\n\nreg [7:0] partial_0, partial_1, partial_2, partial_3;\nreg [7:0] sum_0, sum_1, sum_2;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        partial_0 <= 0;\n    end else begin\n        partial_0 <= {4'b0, A} & {8{B[0]}};\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        partial_1 <= 0;\n    end else begin\n        partial_1 <= {3'b0, A, 1'b0} & {8{B[1]}};\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        partial_2 <= 0;\n    end else begin\n        partial_2 <= {2'b0, A, 2'b0} & {8{B[2]}};\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        partial_3 <= 0;\n    end else begin\n        partial_3 <= {1'b0, A, 3'b0} & {8{B[3]}};\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        sum_0 <= 0;\n    end else begin\n        sum_0 <= partial_0 + partial_1;\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        sum_1 <= 0;\n    end else begin\n        sum_1 <= sum_0 + partial_2;\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        sum_2 <= 0;\n    end else begin\n        sum_2 <= sum_1 + partial_3;\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        P <= 0;\n    end else begin\n        P <= sum_2;\n    end\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement a multi-bit MUX synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 B clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 B clock cycles.",
        "ollama_output_code": "module mux_synchronizer #(\n    parameter WIDTH = 8, // Set the width of the data bus (default 8 bits)\n    parameter SYNC_WIDTH = 2, // Synchronize data_en signal\n    parameter SYNC_CYCLES = 3 // Minimum synchronization cycle\n)(\n    input wire clk,           // Clock signal\n    input wire rst,           // Reset signal\n    input wire [WIDTH-1:0] data_in,  // Data input to be synchronized\n    input wire [SYNC_WIDTH-1:0] data_en,      // Enable signal for data synchronization\n    output reg [WIDTH-1:0] data_out  // Synchronized data output\n);\n\nreg [WIDTH-1:0] sync_data_1;  // First stage of synchronization\nreg [WIDTH-1:0] sync_data_2;  // Second stage of synchronization\nreg [SYNC_WIDTH-1:0] data_en_sync;       // Synchronize data_en signal\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        sync_data_1 <= 0;\n        sync_data_2 <= 0;\n        data_en_sync <= 0;\n        data_out <= 0;\n    end else begin\n        // Synchronizing the enable signal (data_en) across clock cycles\n        data_en_sync <= {data_en_sync[SYNC_WIDTH-1:0], data_en[SYNC_WIDTH-1:SYNC_WIDTH+1]};\n\n        // If data_en is stable high (at least SYNC_CYCLES cycles), sync data_in\n        if (data_en_sync == 2'b11) begin\n            sync_data_1 <= data_in;  // Store data_in in first stage\n            sync_data_2 <= sync_data_1;  // Transfer to second stage\n        end\n\n        // Output the synchronized data from the second stage\n        data_out <= sync_data_2;\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a module for parallel-to-serial conversion, where every four input bits are converted to one output bit. The output signal valid_in indicates the validity of the input at that time.",
        "ollama_output_code": "module parallel_to_serial (\n    input wire clk,              // Clock signal\n    input wire rst,              // Reset signal\n    input wire [3:0] data_in,   // 4-bit parallel input data\n    output reg serial_out,      // Serial output bit\n    output reg valid_out        // Valid signal for output data\n);\n\nreg [3:0] data_buffer;      // To hold the input data\nreg [2:0] count;            // 3-bit counter for shifting out the bits\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        data_buffer <= 4'b0;\n        count <= 3'b0;\n        serial_out <= 1'b0;\n        valid_out <= 1'b0;\n    end else if (data_in) begin\n        if (count == 3'b0) begin\n            data_buffer <= data_in;\n            valid_out <= 1'b1;\n        end else if (count < 2'b11) begin\n            data_buffer[2:0] <= data_buffer[2:0];\n            data_buffer[3] <= data_in[3];\n            serial_out <= data_buffer[3];\n            count <= count + 1;\n\n            if (count == 2'b10) begin\n                valid_out <= 1'b0;\n            end\n        end else begin\n            valid_out <= 1'b0;\n        end\n    end else begin\n        valid_out <= 1'b0;\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement the design where a single clock-cycle width pulse(data_in) is extracted from the A clock(fast) domain and a new single clock-width pulse (data_out) will be created in the clock domain B(slow).",
        "ollama_output_code": "module pulse_synchronizer (\n    input wire clk_a,            // Fast clock A\n    input wire clk_b,            // Slow clock B\n    input wire rst,              // Reset signal\n    input wire data_in,          // Single clock-width pulse in the A domain\n    output reg [1:0] data_out   // Single clock-width pulse in the B domain\n);\n\n    reg sync_1;                  // Synchronize the data_in signal from clk_a to clk_b\n\n    always @(posedge clk_a or posedge rst) begin\n        if (rst) begin\n            sync_1 <= 1'b0;\n        end else begin\n            sync_1 <= data_in;      // First stage synchronizer\n        end\n    end\n\n    always @(posedge clk_b or posedge rst) begin\n        if (rst) begin\n            data_out <= 2'b00;\n        end else begin\n            if (!sync_1 && !data_in) begin\n                data_out <= 2'b11;   // Generate pulse\n            end else begin\n                data_out <= 2'b00;   // Clear pulse after one clock cycle\n            end\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a true dual-port RAM with a depth of 8 and a bit width of 4 bits, with all data initialized to 0000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is valid, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is valid, data is written to the corresponding position through the write_addr signal and write-data signal.",
        "ollama_output_code": "module true_dual_port_ram (\n    input wire clk,             // Clock signal\n    input wire rst,             // Reset signal\n    input wire read_en,         // Read enable signal\n    input wire [2:0] read_addr, // 3-bit address for reading (depth 8)\n    output reg [3:0] read_data, // 4-bit data read from memory\n    input wire write_en,        // Write enable signal\n    input wire [2:0] write_addr,// 3-bit address for writing (depth 8)\n    input wire [3:0] write_data // 4-bit data to be written to memory\n);\n\n    reg [7:0] mem[7:0];\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            for (int i = 0; i < 8; i++) begin\n                mem[i] <= 4'b0000;\n            end\n        end else begin\n            if (write_en) begin\n                mem[write_addr] <= write_data;\n            end\n            if (read_en && read_addr != 3'd7) begin\n                read_data <= mem[read_addr];\n            end\n        end\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a right shifter. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.The register is defined as reg [7:0] q and initialized to 0 using the initial statement. The value of q is right-shifted by 1 bit using the >> operator: q <= (q >> 1).The most significant bit (q[7]) of the register is assigned the value of the input signal (d): q[7] <= d.",
        "ollama_output_code": "module right_shifter (\n    input clk,\n    input d,\n    output reg [7:0] q\n);\n\ninitial begin\n    q = 8'd0;\nend\n\nalways @(posedge clk) begin\n    q <= (q >> 1);\n    q[7] <= d;\nend\n\nendmodule"
    },
    {
        "input_prompt": "Implement a series-parallel conversion circuit, the input end inputs single bit data, and when the module receives 6 input data, the output end outputs the 6bit data after splicing. The module adopts the valid-ready two-way handshake mechanism between the input and upstream, and the valid-only handshake mechanism between the output and downstream. During data concatenation, the received data is placed in the lower part of data_b.",
        "ollama_output_code": "module serial_to_parallel_6bit (\n    input clk,\n    input rst,\n\n    // Input side (valid-ready handshake)\n    input        data_in,\n    input        valid_in,\n    output reg   ready_out,\n\n    // Output side (valid-only handshake)\n    output reg [5:0] data_out,\n    output reg       valid_out\n);\n\nreg [1:0] bit_count;  // Counts from 0 to 6\nreg [7:2] data_b;\nreg [3:2] carry;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        data_b     <= 8'd0;\n        bit_count  <= 2'd0;\n        valid_out  <= 1'b0;\n        ready_out  <= 1'b1;\n        data_out   <= 6'd0;\n    end else begin\n        // Update carry from previous bit\n        carry[3:2] <= (bit_count == 4'd5);\n\n        if (valid_in && ready_out) begin\n            // Shift incoming bit into data_b (LSB first)\n            data_b[1:2] <= {data_in, 1'b0};\n            bit_count <= bit_count + 1;\n\n            if (bit_count == 3'd4) begin\n                carry[1:0] <= (data_in == 1'b1);\n                data_out <= {data_in, data_b[5:2]};\n                valid_out <= 1'b1;\n                bit_count <= 3'd0;\n                data_b <= 8'd0;\n            end else if (bit_count == 4'd4) begin\n                carry[0] <= (data_in == 1'b1);\n                data_out <= {data_in, data_b[5:2]};\n                valid_out <= 1'b1;\n                bit_count <= 3'd0;\n                data_b <= 8'd0;\n            end else if (bit_count == 4'd5) begin\n                data_out <= {data_in, data_b[5:2]}; // Final 6-bit vector\n                valid_out <= 1'b1;\n                bit_count <= 3'd0;\n                data_b <= 8'd0;\n            end\n\n        end\n\n        // Always ready unless currently outputting\n        ready_out <= !(valid_in && bit_count == 4'd5);\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a signal generator module, select the signal wave_choise according to the waveform to send out the corresponding waveform: wave_choice=0, send out the square wave signal; wave_choice=1, sends a sawtooth signal; wave_choice=2, the triangular wave signal is emitted.",
        "ollama_output_code": "module signal_generator (\n    input clk,\n    input rst,\n    input [1:0] wave_choice,        // 0: Square, 1: Sawtooth, 2: Triangle\n    output reg [7:0] signal_out\n);\n\nreg [7:0] counter;\nreg direction;  // Used for triangle wave: 0 = up, 1 = down\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 8'd0;\n        signal_out <= 8'd0;\n        direction <= 1'b0;\n    end else begin\n        case (wave_choice)\n            2'b00: begin\n                // Square wave: toggle every 128 steps\n                counter <= counter + 1;\n                signal_out <= (counter < 128) ? 8'd255 : 8'd0;\n            end\n\n            2'b01: begin\n                // Sawtooth wave: ramp up continuously\n                counter <= counter + 1;\n                signal_out <= counter;\n            end\n\n            2'b10: begin\n                // Triangle wave: ramp up and down\n                if (!direction) begin\n                    counter <= counter + 1;\n                    if (counter == 8'd255) direction <= 1;\n                end else begin\n                    counter <= counter - 1;\n                    if (counter == 8'd0) direction <= 0;\n                end\n                signal_out <= counter;\n            end\n\n            default: signal_out <= 8'd0;\n        endcase\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged.",
        "ollama_output_code": "module traffic_light_controller (\n    input clk,\n    input rst,\n    input pedestrian_button,\n    output reg red,\n    output reg yellow,\n    output reg green\n);\n\n    // State Encoding\n    localparam GREEN  = 2'b00;\n    localparam YELLOW = 2'b01;\n    localparam RED    = 2'b10;\n    localparam INVALID = 2'b11;\n\n    reg [1:0] state, next_state;\n    reg [6:0] counter;  \n    reg shorten_green;  \n    reg [6:0] green_time;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= GREEN;\n            counter <= 0;\n            shorten_green <= 0;\n            green_time <= 60;\n        end else begin\n            state <= next_state;\n\n            // Detect pedestrian button press during green\n            if (state == GREEN && pedestrian_button && counter < 51) begin\n                shorten_green <= 1;\n                green_time <= 10;\n            end else if (state == GREEN && !pedestrian_button) begin\n                shorten_green <= 0;\n                green_time <= 60;\n            end\n\n            // Counter logic\n            if (state != next_state) begin\n                counter <= 0; \n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    // State transition logic\n    always @(*) begin\n        next_state = state;\n\n        case (state)\n            GREEN: begin\n                if ((shorten_green && counter >= 10) || (!shorten_green && counter >= 60))\n                    next_state = YELLOW;\n            end\n            YELLOW: begin\n                if (counter >= 5)\n                    next_state = RED;\n            end\n            RED: begin\n                if (counter >= 10)\n                    next_state = GREEN;\n            end\n            default: next_state = INVALID; \n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            GREEN: begin\n                green  = 1;\n                yellow = 0;\n                red    = 0;\n            end\n            YELLOW: begin\n                green  = 0;\n                yellow = 1;\n                red    = 0;\n            end\n            RED: begin\n                green  = 0;\n                yellow = 0;\n                red    = 1;\n            end\n            default: begin \n                green  = 0;\n                yellow = 0;\n                red    = 0;\n            end\n        endcase\n    end\n\nendmodule"
    },
    {
        "input_prompt": "Implement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output.",
        "ollama_output_code": "module width_converter_8to16 (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    input valid_in,\n    output reg [15:0] data_out,\n    output reg valid_out\n);\n\nreg [7:0] temp;\nreg has_first_byte;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        temp <= 8'd0;\n        data_out <= 16'd0;\n        has_first_byte <= 1'b0;\n        valid_out <= 1'b0;\n    end else begin\n        valid_out <= 1'b0; // default, will be set high when output is ready\n\n        if (valid_in) begin\n            if (!has_first_byte) begin\n                temp <= data_in;\n                has_first_byte <= 1'b1;\n            end else begin\n                data_out <= {temp[7:0],data_in[7:0]}; // high byte first\n                valid_out <= 1'b1;\n                has_first_byte <= 1'b0;\n            end\n        end\n    end\nendmodule"
    },
    {
        "input_prompt": "Implement a module of a ripple 64 bit adder, which is divided into 4 sections to achieve 4-stage pipeline.",
        "ollama_output_code": "module ripple_adder(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] sum\n);\n\nwire [1:0] full_adder_3bit[0:3];\nassign {full_adder_3bit[2], full_adder_3bit[1]} = {a[29:27], a[26:24]};\nassign {full_adder_3bit[1], full_adder_3bit[0]} = {b[29:27], b[26:24]};\n\nassign {sum[31:29], sum[28:26]} = 4'reg {{sum[31:30]}, (a[27] ^ b[27]) | ((a[27] & b[27]) << 1)};\nassign full_adder_3bit[2].cout = 0;\nassign {full_adder_3bit[3], sum[25:23]} = full_adder(full_adder_3bit[2].cin, full_adder_3bit[3].cin);\nassign sum[24] = sum[24];\n\nassign {sum[31:30], sum[28:26]} = 4'reg {{sum[31:30]}, (a[27] ^ b[27]) | ((a[27] & b[27]) << 1)};\nassign full_adder_3bit[2].cout = 0;\nassign {full_adder_3bit[3], sum[25:23]} = full_adder(full_adder_3bit[2].cin, full_adder_3bit[3].cin);\nassign sum[24] = sum[24];\n\nassign full_adder_3bit[1].cout = 0;\nassign {full_adder_3bit[2], full_adder_3bit[0]} = full_adder(full_adder_3bit[1].cin, full_adder_3bit[0].cin);\nassign sum[23] = sum[23];\n\nassign full_adder_3bit[0].cout = 0;\nassign {full_adder_3bit[1], full_adder_3bit[0]} = full_adder(full_adder_3bit[0].cin, full_adder_3bit[0].cin);\nassign sum[22] = sum[22];\n\nendmodule\n\nmodule full_adder (\n    input  cin,\n    output cout,\n    output [1:0] sum\n);\n\nwire [1:0] carry_out;\nassign {carry_out[2], carry_out[1]} = {a[29:28], b[29:28]};\nassign sum[0] = carry_out[1];\nassign sum[1] = carry_out[2];\n\nassign cout = a[30] ^ b[30] | (cin & (~a[30] & ~b[30]));\n\nendmodule"
    },
    {
        "input_prompt": "Implement an ALU for 32bit MIPS-ISA CPU.",
        "ollama_output_code": "module alu_32bit_mips (\n    input [31:0] A,       // Operand 1\n    input [31:0] B,       // Operand 2\n    input [4:0] shamt,    // Shift amount (used for shift ops)\n    input [3:0] alu_ctrl, // ALU control signal\n    output reg [31:0] result,\n    output zero           // Zero flag\n);\n\n    assign zero = (result == 32'b0);\n\n    always @(*) begin\n        case (alu_ctrl)\n            4'b0000: result = A & B;                      // AND\n            4'b0001: result = A | B;                      // OR\n            4'b0010: result = A + B;                      // ADD\n            4'b0110: result = A - B;                      // SUB\n            4'b0111: result = ($signed(A) < $signed(B)) ? 32'd1 : 32'd0; // SLT\n            4'b1000: result = (A < B) ? 32'd1 : 32'd0;    // SLTU\n            4'b1100: result = ~(A | B);                   // NOR\n            4'b0011: result = A ^ B;                      // XOR\n            4'b1001: result = B << shamt;                 // SLL\n            4'b1010: result = B >> shamt;                 // SRL\n            4'b1011: result = $signed(B) >>> shamt;       // SRA\n            default: result = 32'd0;\n        endcase\n    end\n\nendmodule"
    }
]